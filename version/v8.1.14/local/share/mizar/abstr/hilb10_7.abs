:: Prime Representing Polynomial with 10 Unknowns -- Introduction
::  by Karol P\kak
:: 
:: Received September 30, 2022
:: Copyright (c) 2022-2023 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, RELAT_1, ORDINAL4, FINSEQ_1, XBOOLE_0,
      BINOP_1, FUNCT_1, FINSOP_1, SETWISEO, XXREAL_0, TARSKI, NAT_1, ARYTM_3,
      FINSUB_1, SETFAM_1, FINSET_1, ZFMISC_1, CARD_1, PARTFUN1, ARYTM_1,
      FUNCOP_1, FUNCT_4, FINSEQ_2, FUNCT_2, CLASSES1, PRE_POLY, FUNCT_6,
      WAYBEL_4, FUNCT_5, ABIAN, AOFA_I00, NET_1, FUNCT_7, FINSEQOP, MONOID_0,
      MATRIX_1, UPROOTS, HILB10_7;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, CARD_1, NUMBERS, ABIAN,
      RELAT_1, XXREAL_0, XCMPLX_0, FUNCT_1, RELSET_1, FINSET_1, FINSUB_1,
      SETWISEO, PARTFUN1, FUNCT_2, FINSOP_1, FINSEQ_1, FUNCT_3, BINOP_1,
      FINSEQ_2, FUNCT_4, FUNCT_5, FUNCOP_1, NAT_1, CLASSES1, SETFAM_1,
      DOMAIN_1, FINSEQOP, PRE_POLY, POLNOT_1, MONOID_0, MATRIX_1, RLAFFIN3,
      FINSEQ_3, ORDINAL1, MATRIX_3;
 constructors WELLORD2, SETWISEO, ABIAN, FINSOP_1, FINSEQ_4, RFUNCT_3,
      CLASSES1, PRE_POLY, POLNOT_1, MONOID_0, MATRIX_3, RLAFFIN3;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1,
      FINSET_1, XXREAL_0, XREAL_0, NAT_1, CARD_1, FINSEQ_1, FINSEQ_2, VALUED_0,
      RELSET_1, FUNCT_2, FINSUB_1, INT_1, PRE_POLY, NEWTON04, FLEXARY1,
      MSAFREE5, PRE_CIRC, FOMODEL0, AOFA_A00, FUNCT_4, ABIAN, POLNOT_1,
      MEMBERED, MATRIX_1, FINSEQ_3, NEWTON03;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;


begin :: Preliminaries

reserve i,j,n,k,m for Nat,
     a,b,x,y,z for object,
     F,G for FinSequence-yielding FinSequence,
     f,g,p,q for FinSequence,
     X,Y for set,
     D for non empty set;

definition
  let X be finite set;
  func [#]X -> Element of Fin X equals
:: HILB10_7:def 1
    X;
end;

theorem :: HILB10_7:1
  for X1,X2,Y be non empty set
  for F be BinOp of Y
   for B1 be Element of Fin X1, B2 be Element of Fin X2 st B1=B2 &
      (B1 <> {} or F is having_a_unity) & F is associative commutative
   for f1 be Function of X1,Y, f2 be Function of X2,Y st f1|B1=f2|B2 holds
     F$$(B1,f1) = F$$(B2,f2);

theorem :: HILB10_7:2
for D be non empty set, d1,d2 be Element of D, B be BinOp of D st
  B is having_a_unity associative commutative having_an_inverseOp holds
    B.((the_inverseOp_wrt B).d1,d2) =
       (the_inverseOp_wrt B).(B.(d1,(the_inverseOp_wrt B).d2))
  &
    B.(d1,(the_inverseOp_wrt B).d2) =
       (the_inverseOp_wrt B).(B.((the_inverseOp_wrt B).d1,d2));

theorem :: HILB10_7:3
  for D be non empty set, A,M be BinOp of D  st
    A is commutative associative having_a_unity &
    M is commutative & M is_distributive_wrt A &
    (for d be Element of D holds M.(the_unity_wrt A,d) = the_unity_wrt A)
  for X,Y be non empty finite set
    for f be Function of X,D, g be Function of Y,D
      for a be Element of Fin X,b be Element of Fin Y
        holds
   A $$ ([:a,b:],M*(f,g))=M. ( A$$(a,f),A$$(b,g));

theorem :: HILB10_7:4
  for D be non empty set, M,A be BinOp of D, d be Element of D  st
    M is having_a_unity &
    A is associative having_a_unity having_an_inverseOp &
    M is_distributive_wrt A
  holds
   (n is even implies M "**" (n|-> (the_inverseOp_wrt A).d) =
      M "**" (n|-> d) ) &
   (n is odd implies M "**" (n|-> (the_inverseOp_wrt A).d) =
      (the_inverseOp_wrt A).(M "**" (n|-> d)) );

theorem :: HILB10_7:5
  for s be FinSequence st s"{y}<>{}
    ex p be Permutation of Seg (len s) st (s*p) . (len s) = y & p = p";

registration
  let D be non empty set;
  cluster non empty non-empty for FinSequence of D*;
end;

registration
  let X,Y be non empty set;
  cluster UNION(X,Y) -> non empty;
end;

registration
  let X,Y be finite set;
  cluster UNION(X,Y) -> finite;
end;

theorem :: HILB10_7:6
  for X,Y be set holds UNION(bool X,bool Y)=bool(X\/Y);

theorem :: HILB10_7:7
  for X,Y1,Y2 be set holds UNION(X,Y1\/Y2) = UNION(X,Y1)\/UNION(X,Y2);

theorem :: HILB10_7:8
  X misses union Y implies card UNION(Y,{X}) = card Y;

theorem :: HILB10_7:9
   m<>0 implies 2 * card bool (Seg m\{1}) = card bool (Seg (1+m)\{1});

begin :: Selected Operations on Set Families

definition
  let X be set,a,b be object;
  func Ext(X,a,b) -> set equals
:: HILB10_7:def 2
    {A\/{b} where A is Element of X: a in A} \/
    {A      where A is Element of X: not a in A & A in X};
end;

definition
  let X be set,a,b be object;
  func swap(X,a,b) -> set equals
:: HILB10_7:def 3
    {(A\{a})\/{b} where A is Element of X: a in A} \/
     {A\/{a}      where A is Element of X: not a in A & A in X};
end;

theorem :: HILB10_7:10
  not y in union Y implies
        card Y = card Ext(Y,x,y);

theorem :: HILB10_7:11
  not y in union Y implies
       card Y = card swap(Y,x,y);

theorem :: HILB10_7:12
  swap({},x,y)={};

theorem :: HILB10_7:13
  swap(X\/Y,x,y)=swap(X,x,y)\/swap(Y,x,y);

theorem :: HILB10_7:14
  Y in swap(X,x,y) & x<>y & not y in union X implies (x in Y iff not y in Y);

theorem :: HILB10_7:15
  Ext({},x,y)={};

theorem :: HILB10_7:16
  Ext(X\/Y,x,y)=Ext(X,x,y)\/Ext(Y,x,y);

theorem :: HILB10_7:17
  Y in Ext(X,x,y) & not y in union X implies (x in Y iff y in Y);

registration
  let X be finite set,a,b be object;
  cluster swap(X,a,b)->finite;
  cluster Ext(X,a,b)->finite;
end;

definition
  let f be Function,a,b be object;
  func Swap(f,a,b) -> Function means
:: HILB10_7:def 4
    dom it = dom f &
    for x st x in dom f holds
     (    a in f.x implies it.x = ((f.x)\{a} )\/{b}) &
     (not a in f.x implies it.x = (f.x)\/{a} );
end;

definition
  let f be Function,a,b be object;
  func Ext(f,a,b) -> Function means
:: HILB10_7:def 5
    dom it = dom f &
    for x st x in dom f holds
     (    a in f.x implies it.x = (f.x)\/{b} ) &
     (not a in f.x implies it.x = (f.x) );
end;


registration
  let f be FinSequence,a,b be object;
  cluster Swap(f,a,b) -> (len f)-element FinSequence-like;
  cluster Ext(f,a,b) -> (len f)-element FinSequence-like;
end;

theorem :: HILB10_7:18
  for f,g be FinSequence holds
    Swap(f^g,a,b) = Swap(f,a,b)^Swap(g,a,b);

theorem :: HILB10_7:19
  for f,g be FinSequence holds
    Ext(f^g,a,b) = Ext(f,a,b)^Ext(g,a,b);

theorem :: HILB10_7:20
  for f be Function st b<>x & b <> y holds
    b in Ext(f,x,y).a iff b in f.a;

theorem :: HILB10_7:21
  for f be Function st b<>x & b <> y holds
    b in Swap(f,x,y).a iff b in f.a;

theorem :: HILB10_7:22
  x<>y & not y in union X & not y in union Y  implies
    Ext(X,x,y) misses swap(Y,x,y);

theorem :: HILB10_7:23
  for f,g be Function holds Swap(f,x,y)*g = Swap(f*g,x,y);

theorem :: HILB10_7:24
  for f be Function holds Swap(f,x,y)|X = Swap(f|X,x,y);

theorem :: HILB10_7:25
  for f,g be Function holds Ext(f,x,y)*g = Ext(f*g,x,y);

theorem :: HILB10_7:26
  for f be Function holds Ext(f,x,y)|X = Ext(f|X,x,y);

registration
  let X be finite set;
  cluster -> card X -element X-valued for Enumeration of X;
end;

theorem :: HILB10_7:27
  for F be finite set
  for E be Enumeration of F st  not y in union F  holds
    Swap(E,x,y) is  Enumeration of swap(F,x,y);

theorem :: HILB10_7:28
  for F be finite set
  for E be Enumeration of F st  not y in union F  holds
    Ext(E,x,y) is  Enumeration of Ext(F,x,y);

theorem :: HILB10_7:29
  x in X implies Ext({X},x,y) = { X\/{y} };

theorem :: HILB10_7:30
  not x in X implies Ext({X},x,y) = { X };

theorem :: HILB10_7:31
  x in X implies swap({X},x,y) = { (X\{x}) \/{y} };

theorem :: HILB10_7:32
  not x in X implies swap({X},x,y) = { X\/{x} };

registration
  let X be non empty set;
  let a,b be object;
  cluster Ext(X,a,b) -> non empty;
  cluster swap(X,a,b) -> non empty;
end;

theorem :: HILB10_7:33
  not y in union X & not y in union Y implies
    (X misses Y iff Ext(X,x,y) misses Ext(Y,x,y));

theorem :: HILB10_7:34
  x<>y & not y in union X & not y in union Y implies
    (X misses Y iff swap(X,x,y) misses swap(Y,x,y));

theorem :: HILB10_7:35
  for f be Function st z in dom f holds Ext(<*f.z*>,x,y) = <*Ext(f,x,y).z*>;

theorem :: HILB10_7:36
  for f be Function st z in dom f holds Swap(<*f.z*>,x,y) = <*Swap(f,x,y).z*>;

theorem :: HILB10_7:37
  for f be Function st z in dom f holds Ext({f.z},x,y) = {Ext(f,x,y).z};

theorem :: HILB10_7:38
  for f be Function st z in dom f holds swap({f.z},x,y) = {Swap(f,x,y).z};

theorem :: HILB10_7:39
 m<>0 implies  bool(Seg (m+2)\{1}) =
    Ext(bool(Seg (m+1)\{1}),1+m,2+m)\/
    swap(bool(Seg (m+1)\{1}),1+m,2+m);

begin :: Function where each Value is Repeated an Even Number of Times

definition
  let f be finite Function;
  attr f is with_evenly_repeated_values means
:: HILB10_7:def 6
    card (f"{y}) is even;
end;

registration
  cluster empty -> with_evenly_repeated_values for finite Function;
  let x be object;
  cluster <*x,x*> -> with_evenly_repeated_values;
end;

theorem :: HILB10_7:40
  for f,g be with_evenly_repeated_values FinSequence holds
     f^g is with_evenly_repeated_values;

definition
  let F be set;
  attr F is with_evenly_repeated_values-member means
:: HILB10_7:def 7
    for y be object st y in F holds
      y is with_evenly_repeated_values finite Function;
end;

registration
  cluster empty -> with_evenly_repeated_values-member for set;
end;

registration
  let X be FinSequence-membered set;
  cluster -> FinSequence-membered for Element of Fin X;
  let Y be FinSequence-membered set;
  cluster X\/Y -> FinSequence-membered;
end;

theorem :: HILB10_7:41
  for P1,S1,S2 be FinSequence-membered set holds
     P1^(S1\/S2) = P1^S1 \/ P1^S2;

theorem :: HILB10_7:42
  for P1,P2,S1 be FinSequence-membered set holds
   (P1\/P2)^S1 = P1^S1 \/ P2^S1;

theorem :: HILB10_7:43
  for f,g be FinSequence holds
     {f}^{g} = {f^g};

registration
  let f be with_evenly_repeated_values finite Function;
  cluster {f} -> with_evenly_repeated_values-member;
  let g be with_evenly_repeated_values finite Function;
  cluster {f,g} -> with_evenly_repeated_values-member;
end;

registration
  let F,G be with_evenly_repeated_values-member FinSequence-membered set;
  cluster F^G ->with_evenly_repeated_values-member;
end;

theorem :: HILB10_7:44
  for f be finite Function, p be Permutation of dom f holds
    f is with_evenly_repeated_values iff f*p is with_evenly_repeated_values;

begin :: Cartesian Product of Domains in Finite Sequences

definition
  let F be FinSequence-yielding FinSequence;
  func doms F -> finite Subset of NAT* means
:: HILB10_7:def 8
    for x be object holds x in it iff
      ex p be FinSequence st p=x & len p = len F &
         for i st i in dom p holds p.i in dom (F.i);
end;

theorem :: HILB10_7:45
  doms F is non empty iff F is non-empty;

theorem :: HILB10_7:46
  doms {} = { {} };

registration
  let F be FinSequence-yielding FinSequence;
  cluster doms F -> FinSequence-membered;
end;

theorem :: HILB10_7:47
  p in doms F iff len p = len F &
         for i st i in dom p holds p.i in dom (F.i);

registration
  let F be FinSequence-yielding FinSequence;
  cluster -> NAT-valued for Element of doms F;
end;

registration
  let F be non-empty FinSequence-yielding FinSequence;
  cluster doms F -> non empty;
end;

theorem :: HILB10_7:48
  f in doms F & g in doms G implies f^g in doms (F^G);


theorem :: HILB10_7:49
  for P,S be FinSequence-membered set st
    P c= doms F & S c= doms G holds P^S c= doms (F^G);

theorem :: HILB10_7:50
  (len f=len F or len g = len G) & f^g in doms (F^G) implies
    f in doms F & g in doms G;

theorem :: HILB10_7:51
  f in doms <*g*> iff len f = 1 & f.1 in dom g;

theorem :: HILB10_7:52
  for F,g,x holds
    doms (F^<* g^<*x*> *>) = doms (F^<* g *>) \/
      {f^<*1 + len g*> where f is Element of doms F:f in doms F};

theorem :: HILB10_7:53
  for F,x holds
    doms (F^<* <*x*> *>) = {f^<* 1 *> where f is Element of doms F:f in doms F}
;


theorem :: HILB10_7:54
  for F,G be FinSequence-yielding FinSequence holds
     NAT-concatenation .: [:doms F,doms G:] = doms (F^G);

theorem :: HILB10_7:55
  doms <*f*> = { <*i*> where i is Element of NAT:i in dom f};

registration
  let n,F;
  cluster F|n -> FinSequence-yielding;
end;

theorem :: HILB10_7:56
  f in doms F implies f|n in doms (F|n);

theorem :: HILB10_7:57
   card doms <*g*> = len g;

theorem :: HILB10_7:58
  card doms (F^<*f*>) = (card doms F) * len f;

begin :: Some Operations on Finite Sequences

definition
  let F be FinSequence-yielding FinSequence;
  func App F -> FinSequence-yielding Function  means
:: HILB10_7:def 9
    dom it = doms F &
    for p be FinSequence st p in doms F holds len (it.p) = len p &
      for i st i in dom p holds (it.p).i = F.i.(p.i);
end;

definition
  let D be non empty set;
  let F be D*-valued FinSequence;
  redefine func App F -> Function of doms F,D*;
end;

theorem :: HILB10_7:59
  (App {}).{} = {};

theorem :: HILB10_7:60
  i in dom f implies (App <*f*>).<*i*> = <*f.i*>;

theorem :: HILB10_7:61
  f in doms F & g in doms G implies
     (App(F^G)).(f^g) = ((App F).f) ^ ((App G).g);

registration
  let D be non empty set;
  let F be non empty D*-valued FinSequence;
  cluster App F -> non-empty;
end;

definition
  let D be non empty set;
  let f be D* -valued Function;
  let x be object;
  redefine func f.x -> FinSequence of D;
end;

definition
  let D be non empty set;
  let B be BinOp of D;
  let F be D* -valued Function;
  func B "**" F -> Function of dom F,D means
:: HILB10_7:def 10
      for x st x in dom F holds it.x = B "**" (F.x);
end;

reserve
  B,A,M for BinOp of D,
  F,G for D* -valued FinSequence,
  f for FinSequence of D,
  d,d1,d2 for Element of D;

registration
  let D be non empty set;
  let B be BinOp of D;
  let F be D* -valued FinSequence;
  cluster B "**" F -> (len F)-element FinSequence-like;
end;

definition
  let D be set;
  let f be FinSequence of D;
  redefine func <* f *> ->  FinSequence of D*;
end;

theorem :: HILB10_7:62
  A "**" <*f*> = <* A "**" f *>;

theorem :: HILB10_7:63
  A "**" (F^G) = ( A "**" F )^(A "**"G);

registration
  let f be non empty FinSequence;
  cluster <*f*> -> non-empty;
end;

reserve
  F,G for non-empty non empty FinSequence of D*,
  f for non empty FinSequence of D;

theorem :: HILB10_7:64
  A is commutative associative
implies
  for f,g be non empty FinSequence
    for F be Function of dom f,D, G be Function of dom g,D,
        FG be Function of dom (f^g),D st f=F & g=G & f^g = FG
    holds
  A$$ ([#]dom (f^g),FG) = A.(A$$([#]dom f,F),A$$([#]dom g,G));

theorem :: HILB10_7:65
  M is commutative associative
implies
  M $$ ([#]dom (F^G), A "**" (F^G)) =
    M.(M $$ ([#]dom F, A "**" F), M $$ ([#]dom G, A "**" G));

theorem :: HILB10_7:66
  M is commutative associative
implies
  M $$ ([#]dom <*f*>,A "**" <*f*>) = A "**" f;

theorem :: HILB10_7:67
  M is commutative associative & A is commutative associative &
    M is_left_distributive_wrt A
  implies
   for fM be Function of dom f,D st
     for x st x in dom f holds
         fM.x = M.( M$$ ([#]dom F, A "**" F), f.x) holds
   M $$ ([#]dom (F^<*f*>), A "**" (F^<*f*>))= A $$ ([#]dom f,fM);

theorem :: HILB10_7:68
  len F = 1 & M is commutative associative &
    A  is commutative associative implies
  M $$ ([#]dom F, A "**" F) = A $$ ([#]dom App F, M "**" App(F));

theorem :: HILB10_7:69
  M is commutative associative &
  A is commutative associative having_a_unity &
  M is_distributive_wrt A
implies
  M $$ ([#]dom F, A "**" F) = A $$ ([#]dom App F, M "**" App(F));

begin :: Combination of Sign and Characteristic Functions

definition
  let D be non empty set;
  let B be BinOp of D;
  let f be FinSequence of D;
  let X be set;
  func SignGen(f,B,X) -> FinSequence of D means
:: HILB10_7:def 11
    dom it = dom f &
    for i st i in dom it holds
      ( i in X implies it.i = (the_inverseOp_wrt B).(f.i)) &
      ( not i in X implies it.i = f.i);
end;

registration
  let D be non empty set;
  let B be BinOp of D;
  let f be FinSequence of D;
  let X be set;
  cluster SignGen(f,B,X) -> len f-element;
end;

reserve f,g for FinSequence of D,
        a,b,c for set,
        F,F1,F2 for finite set;

theorem :: HILB10_7:70
  X misses dom f implies SignGen(f,B,X) = f;

theorem :: HILB10_7:71
  SignGen(f,B,{}) = f;

theorem :: HILB10_7:72
  SignGen(f|n,B,X) = SignGen(f,B,X) |n;

theorem :: HILB10_7:73
  n+1 = len f & n+1 in X implies
    SignGen(f,B,X) = SignGen(f|n,B,X)^<*(the_inverseOp_wrt B).(f.(n+1))*>;

theorem :: HILB10_7:74
  n+1 = len f & not n+1 in X implies
    SignGen(f,B,X) = SignGen(f|n,B,X)^<*f.(n+1)*>;

theorem :: HILB10_7:75
  dom f c= X implies SignGen(f,B,X) = (the_inverseOp_wrt B)*f;

theorem :: HILB10_7:76
  B is having_a_unity associative having_an_inverseOp implies
    SignGen(SignGen(f,B,X),B,X) = f;

registration
  let E be non empty set, D be set, p be D-valued FinSequence,
      h be Function of D,E;
  cluster h*p -> (len p)-element FinSequence-like;
end;

definition
  let D be non empty set;
  let B be BinOp of D;
  let f be FinSequence of D;
  let F be finite set;
  func SignGenOp(f,B,F) -> Function of F,D* means
:: HILB10_7:def 12
    X in F implies it.X = SignGen(f,B,X);
end;

theorem :: HILB10_7:77
  for E be Enumeration of {x} holds E = <*x*>;

theorem :: HILB10_7:78
 for E be Enumeration of {X} holds SignGenOp(f,B,{X}) * E= <* SignGen(f,B,X) *>
;

theorem :: HILB10_7:79
  for E1 be Enumeration of F1,E2 be Enumeration of F2 st F1 misses F2
    holds E1^E2 is Enumeration of F1\/F2;

theorem :: HILB10_7:80
for E be Enumeration of F st i in dom E or i in dom (SignGenOp(f,B,F)*E)
  holds (SignGenOp(f,B,F) * E).i = SignGen(f,B,E.i);

theorem :: HILB10_7:81
  for E1 be Enumeration of F1,E2 be Enumeration of F2,
      E12 be Enumeration of F1\/F2 st E12=E1^E2 holds
  SignGenOp(f,B,F1\/F2) * E12 =
    (SignGenOp(f,B,F1) * E1)^(SignGenOp(f,B,F2) * E2);

theorem :: HILB10_7:82
  for E be Enumeration of F st
    (B is having_a_unity or len f >= 1)& not 1+len f in union F
  holds
    B "**" (SignGenOp(f^<*d*>,B,F)*E) = B[:](B "**" SignGenOp(f,B,F)*E,d);

theorem :: HILB10_7:83
  for E be Enumeration of F st
    (B is having_a_unity or len f >= 1) & 1+len f in meet F
  holds
    B "**" (SignGenOp(f^<*d*>,B,F)*E) =
      B[:](B "**" SignGenOp(f,B,F)*E,(the_inverseOp_wrt B).d);


theorem :: HILB10_7:84
  for E be Enumeration of F st
    (B is having_a_unity or len f >= 1) & B is associative &
     not 1+len f in union F & not 2+len f in union F
  holds
    B "**"(SignGenOp(f^<*d1*>^<*d2*>,B,F)*E) =
      B"**"(SignGenOp(f^<*B.(d1,d2)*>,B,F)*E);

theorem :: HILB10_7:85
  for E be Enumeration of F st
    (B is having_a_unity or len f >= 1) & B is associative &
     not 1+len f in union F & 2+len f in meet F
  holds
    B "**" (SignGenOp(f^<*d1*>^<*d2*>,B,F)*E)
      = B"**" (SignGenOp(f^<*B.(d1,(the_inverseOp_wrt B).d2)*>,B,F)*E);

theorem :: HILB10_7:86
  for E be Enumeration of F st
    B is having_a_unity associative commutative having_an_inverseOp &
    1+len f in meet F & not 2+len f in union F
  holds
    B "**" (SignGenOp(f^<*d1*>^<*d2*>,B,F)*E) =
      B"**" (SignGenOp(f^<*B.(d1,(the_inverseOp_wrt B).d2)*>,B,F)*E);

theorem :: HILB10_7:87
  for E be Enumeration of F st
    B is having_a_unity associative commutative having_an_inverseOp &
    1+len f in meet F & 2+len f in meet F
  holds
    B "**"(SignGenOp(f^<*d1*>^<*d2*>,B,F)*E) =
      B"**"(SignGenOp(f^<*B.(d1,d2)*>,B,F)*E);

theorem :: HILB10_7:88
  for E be Enumeration of F st X misses union F holds
    ex Ex be Enumeration of UNION(F,{X}) st
      for i st i in dom E holds Ex.i = X\/E.i;

theorem :: HILB10_7:89
  SignGen(f,B,X) = SignGen(f,B,X/\dom f);

theorem :: HILB10_7:90
  for E1 be Enumeration of F1,E2 be Enumeration of F2 st
    card F1 = card F2 &
    for i st i in dom E1 holds dom f /\ E1.i = dom f /\ E2.i holds
      SignGenOp(f,A,F1)*E1 = SignGenOp(f,A,F2)*E2;

theorem :: HILB10_7:91
  A is having_a_unity associative commutative having_an_inverseOp
implies
  for F be finite non empty set st union F c= dom f
    for F1,F2 be finite set st F1 = UNION(F,bool {len f+1}) &
       F2 = UNION(F,bool {len f+1,len f+2}) holds
    ex E1 be Enumeration of F1,E2 be Enumeration of F2 st
      A "**" (SignGenOp(f^<*d1*>^<*d2*>,A,F2)*E2) = (
         A"**" (SignGenOp(f^<*A.(d1,d2)*>,A,F1)*E1)) ^
        (A"**" (SignGenOp(f^<*A.(d1,(the_inverseOp_wrt A).d2)*>,A,F1)*E1));

begin :: Product over All Combinations of Sings

definition
  let D be non empty set;
  let A be BinOp of D;
  let M be BinOp of D such that
 M is commutative associative;
  let f be FinSequence of D;
  let F be finite set;
  func SignGenOp(f,M,A,F)-> Element of D means
:: HILB10_7:def 13
    for E be Enumeration of bool F holds
      it = M $$ ([#]dom (SignGenOp(f,A,bool F) * E),
          A "**" (SignGenOp(f,A,bool F) * E));
end;

theorem :: HILB10_7:92
  M is commutative associative &
      A is commutative & A is associative & A is having_a_unity &
      A is having_an_inverseOp &
      M is_distributive_wrt A
implies
  for CE1,CE2,CE12 be non-empty non empty FinSequence of D* st
      CE12 = CE1 ^  CE2
  for S1 be Element of Fin dom App CE1, s2 be Element of dom App CE2,
      S12 be Element of Fin dom App CE12 st S12=S1^{s2}
  holds
    M.(A $$ (S1,M "**" App CE1),(M "**" App CE2).s2) =
      A $$ (S12,M "**" App CE12);

theorem :: HILB10_7:93
  M is commutative associative &
  A is commutative & A is associative & A is having_a_unity &
  A is having_an_inverseOp &
  M is_distributive_wrt A
implies
  for CE1,CE2,CE12 be non-empty non empty FinSequence of D* st
    CE12 = CE1 ^ CE2
  for S1 be Element of Fin dom App CE1,S2 be Element of Fin dom App CE2,
    S12 be Element of Fin dom App CE12 st S12=S1^S2
  holds
    M.(A $$ (S1,M "**" App CE1),A $$ (S2,M "**" App CE2)) =
      A $$ (S12,M "**" App CE12);

theorem :: HILB10_7:94
  for E1 be Enumeration of F1 holds
    doms (SignGenOp(f,A,F1) * E1) c= doms (SignGenOp(f^g,A,F1) * E1);

theorem :: HILB10_7:95
  A is having_a_unity commutative associative
implies
  for E1 be Enumeration of F1
  for CE1,CE2 be non-empty non empty FinSequence of D* st
    CE1 = SignGenOp(f,A,F1) * E1 & CE2 = SignGenOp(f^g,A,F1) * E1
  for S1 be Element of Fin dom App CE1
  for S2 be Element of Fin dom App CE2 st S1=S2 holds
    A $$ (S1,M "**" App CE1) = A $$ (S2,M "**" App CE2);


theorem :: HILB10_7:96
  for E be Enumeration of F st len E = n + 1 holds
    E|n is Enumeration of F\{E.len E} &
    <*E.len E*> is Enumeration of {E.len E} &
    F = (F\{E.len E}) \/ {E.len E};

registration
  let F be with_evenly_repeated_values-member set;
  cluster -> finite Function-like Relation-like for Element of F;
end;

registration
  let F be with_evenly_repeated_values-member set;
  cluster -> with_evenly_repeated_values for Element of F;
end;

theorem :: HILB10_7:97
  for E1 be Enumeration of F1
    for p be Function st union F1 c= dom p & p|union F1 is one-to-one holds
     (.:p)*E1 is Enumeration of .:p.:F1 & card E1 = card ((.:p)*E1);

theorem :: HILB10_7:98
  for E1 be Enumeration of F1
    for g be Function st
       union F1 c= dom g & g|union F1 is one-to-one
       for gE1 be Enumeration of .:g.:F1 st gE1 = (.:g)*E1
for fg be FinSequence of D st g.:dom f c= dom fg
for s be FinSequence st s in doms (SignGenOp(f,A,F1) * E1) & rng s c= dom g
   holds
  g*s in doms (SignGenOp(fg,A,.:g.:F1) * gE1);

theorem :: HILB10_7:99
  for E1 be Enumeration of F1
    for g be Function st
       union F1 c= dom g & g is one-to-one
       for gE1 be Enumeration of .:g.:F1 st gE1 = (.:g)*E1
    for fg be FinSequence of D st fg = (f*g") | dom fg & g.:dom f c= dom fg
    for s be FinSequence st s in doms (SignGenOp(f,A,F1) * E1) & rng s c= dom g
       holds
(App (SignGenOp(f,A,F1) * E1)).s
        = (App (SignGenOp(fg,A,.:g.:F1) * gE1)).(g*s);

theorem :: HILB10_7:100
  for E1 be Enumeration of F1 st union F1 c= dom f
    for g be Permutation of dom f
       for gE1 be Enumeration of .:g.:F1 st gE1 = (.:g)*E1
for fg be FinSequence of D st fg = f*g"
  for S1 be Element of Fin dom App (SignGenOp(f,A,F1) * E1)
holds
  {g*s where s is FinSequence of NAT: s in S1} is
      Element of Fin dom App (SignGenOp(fg,A,.:g.:F1) * gE1);

theorem :: HILB10_7:101
  A is having_a_unity commutative associative
implies
  for E1 be Enumeration of F1 st union F1 c= dom f
    for g be Permutation of dom f
       for gE1 be Enumeration of .:g.:F1 st gE1 = (.:g)*E1
for fg be FinSequence of D st fg = f*g"
  for CE1,CE2 be non-empty non empty FinSequence of D* st
        CE1 = SignGenOp(f,A,F1) * E1 & CE2 = SignGenOp(fg,A,.:g.:F1) * gE1
  for S1 be Element of Fin dom App CE1,
      S2 be Element of Fin dom App CE2 st
  S2 = {g*s where s is FinSequence of NAT: s in S1}holds
  A $$ (S1,M "**" App CE1) = A $$ (S2,M "**" App CE2);

theorem :: HILB10_7:102
  for E1 be Enumeration of F1 st n in dom f holds
    (len E1)|-> n in doms(SignGenOp(f,A,F1) * E1);

theorem :: HILB10_7:103
  B is having_a_unity associative commutative having_an_inverseOp
implies
    (the_inverseOp_wrt B).(B.(d1,d2)) =
         B.((the_inverseOp_wrt B).d1,(the_inverseOp_wrt B).d2);

registration
  let x be object, n be even Nat;
  cluster n |-> x -> with_evenly_repeated_values;
end;

theorem :: HILB10_7:104
  for f,g be FinSequence st f^g is with_evenly_repeated_values &
     f is with_evenly_repeated_values holds g is with_evenly_repeated_values;
theorem :: HILB10_7:105
  for f,g be FinSequence st f^g is with_evenly_repeated_values &
    g is with_evenly_repeated_values holds f is with_evenly_repeated_values;

registration
  let x be object, n be even Nat;
  cluster n |-> x -> with_evenly_repeated_values;
end;

registration
  let X,Y be with_evenly_repeated_values-member set;
  cluster X\/Y -> with_evenly_repeated_values-member;
end;

definition
  let n,k be Nat;
  func doms(n,k)-> FinSequence-membered finite set equals
:: HILB10_7:def 14
       k-tuples_on Seg n;
end;

registration
  let n,k be Nat;
  cluster -> (Seg n)-valued for Element of doms(n,k);
end;

registration
  let n be non empty Nat,k be Nat;
  cluster doms(n,k) -> non empty;
  cluster -> k-element for Element of doms(n,k);
end;

theorem :: HILB10_7:106
  for E be Enumeration of F holds
    doms(SignGenOp(f,A,F)*E) = doms(len f,card F);

theorem :: HILB10_7:107
  for E1 be Enumeration of F1,E2 be Enumeration of F2 st
    card F1 = card F2 & len f <= len g holds
  doms (SignGenOp(f,A,F1)*E1) c= doms (SignGenOp(g,A,F2)*E2);

theorem :: HILB10_7:108
  for E1 be Enumeration of F1,E2 be Enumeration of F2 st
    card F1 = card F2 holds
  doms (SignGenOp(f,A,F1)*E1) = doms (SignGenOp(f,A,F2)*E2);

theorem :: HILB10_7:109
   for E be Enumeration of F, p be Permutation of dom E holds
    E*p is Enumeration of F;

theorem :: HILB10_7:110
  for E be Enumeration of F, p be Permutation of dom E
    for s be FinSequence st s in doms (SignGenOp(f,A,F) * E)
      holds s*p in doms (SignGenOp(f,A,F) * (E * p));


theorem :: HILB10_7:111
  for E be Enumeration of F, p be Permutation of dom E
    for s be FinSequence st s in doms (SignGenOp(f,A,F) * E) holds
     ((App (SignGenOp(f,A,F) * E)).s)*p =
        ((App (SignGenOp(f,A,F) * (E*p))).(s*p));

theorem :: HILB10_7:112
  M is commutative associative
implies
  for E be Enumeration of F, p be Permutation of dom E
    for s be FinSequence st
      s in doms (SignGenOp(f,A,F) * E) & (len s >=1 or M is having_a_unity)
    holds
      (M "**" App (SignGenOp(f,A,F) * E)).s =
      (M "**" App (SignGenOp(f,A,F) * (E*p))).(s*p);

theorem :: HILB10_7:113
  for E be Enumeration of F, p be Permutation of dom E
  for S be Element of Fin dom App (SignGenOp(f,A,F) * E)
     holds
   {s*p where s is FinSequence of NAT: s in S}
     is Element of Fin dom App (SignGenOp(f,A,F) * (E*p));

theorem :: HILB10_7:114
  for E be Enumeration of F, p be Permutation of dom E
  for S be Element of Fin doms(n,card F) holds
   {s*p where s is FinSequence of NAT: s in S}
     is Element of Fin doms(n,card F);

theorem :: HILB10_7:115
  M is commutative associative &
  A is having_a_unity commutative associative
implies
  for E be Enumeration of F, p be Permutation of dom E st
    M is having_a_unity or len E >= 1
  for CE,CEp be non-empty non empty FinSequence of D* st
    CE = SignGenOp(f,A,F) * E & CEp=SignGenOp(f,A,F) * (E*p)
  for S be Element of Fin dom App CE,
      Sp be Element of Fin dom App CEp st
    Sp = {s*p where s is FinSequence of NAT: s in S}
  holds
   A$$(S, M "**" App CE) = A$$(Sp,M "**" App CEp);

theorem :: HILB10_7:116
  A is having_a_unity associative having_an_inverseOp
implies
  for F, Fb be finite set st Fb = UNION(F,bool {len f+1}) & union F c= dom f
    for E1 be Enumeration of Fb
      ex E2 be Enumeration of Fb st
    SignGenOp(f^<* d1 *>,A,Fb)*E1 =
      SignGenOp(f^<*(the_inverseOp_wrt A).d1 *>,A,Fb)*E2;

theorem :: HILB10_7:117
  A is having_a_unity associative commutative having_an_inverseOp
implies
  for F be finite non empty set st union F c= dom f
      for F1,F2 be finite set st F1 = UNION(F,bool {len f+1}) &
            F2 = UNION(F,bool {len f+1,len f+2}) holds
     ex E1,E2 be Enumeration of F1,
        E be Enumeration of F2 st
A "**" (SignGenOp(f^<*d1*>^<*d2*>,A,F2)*E) = (
     A"**" (SignGenOp(f^<*A.(d1,d2)*>,A,F1)*E1)) ^
    (A"**" (SignGenOp(f^<*A.((the_inverseOp_wrt A).d1,d2)*>,A,F1)*E2));

theorem :: HILB10_7:118
  A is having_a_unity
implies
  for E be Enumeration of F
    for s be FinSequence st F={} & s in doms (SignGenOp(f,B,F) * E) holds
     (A "**" App (SignGenOp(f,B,F) * E)).s = the_unity_wrt A;

theorem :: HILB10_7:119
  for E be Enumeration of F, p be Permutation of dom E
    for S be Subset of doms(n,card F) holds
     {s*p where s is FinSequence of NAT: s in S} is Subset  of doms(n,card F);

theorem :: HILB10_7:120
  for f,g be FinSequence st
    (len f=n or len g = m) & f^g in doms(k,n+m) holds
  f in doms(k,n) & g in doms(k,m);

theorem :: HILB10_7:121
  for f be FinSequence st f in doms(n,k) holds len f = k;

theorem :: HILB10_7:122
  for f,g be FinSequence holds
    f in doms(k,n) & g in doms(k,m) implies f^g in doms(k,n+m);

theorem :: HILB10_7:123
  doms(k,n)^doms(k,m) = doms(k,n+m);

theorem :: HILB10_7:124
   for E be Enumeration of F, p be Permutation of dom E
   for s be FinSequence st s in doms(m,card F)
     holds s*p in doms(m,card F);

theorem :: HILB10_7:125
  k <= n implies doms(k,m) c= doms(n,m);

theorem :: HILB10_7:126
  A is commutative associative having_a_unity having_an_inverseOp &
  M is associative commutative having_a_unity &
  M is_distributive_wrt A
implies
  for E1 be Enumeration of F1, E2 be Enumeration of F2 st
    union F1 c= Seg (1+m) & union F2 c= Seg (1+m)
  for Ee be Enumeration of Ext(F1,1+m,2+m),
      Es be Enumeration of swap(F2,1+m,2+m) st
    Ee = Ext(E1,1+m,2+m) & Es = Swap(E2,1+m,2+m)
  for Ees be Enumeration of Ext(F1,1+m,2+m)\/swap(F2,1+m,2+m) st Ees=Ee^Es
  for s1,s2 be FinSequence st
    s1 in doms(m+1,card F1) & s2 in doms(m+1,card F2) &
      s1^s2 is with_evenly_repeated_values &
    card (s1"{1+m}) = card (s2"{1+m})
  ex S be Subset of doms(m+2,card F1+card F2) st
    (card (s1"{1+m}) = 0 implies s1^s2 in S) &
    S is with_evenly_repeated_values-member &
    for CE1,CE2 be FinSequence of D*, f,d1,d2 st len f = m &
      CE1 = SignGenOp(f^<*A . (d1,d2)*>,A,F1) * E1 &
      CE2 = SignGenOp(f^<*A.( (the_inverseOp_wrt A).d1,d2)*>,A,F2) * E2
    for CFes be non-empty non empty FinSequence of D* st
        CFes = SignGenOp(f^<*d1*>^<*d2*>,A,
               Ext(F1,1+len f,2+len f)\/swap(F2,1+len f,2+len f) ) * Ees
    for Sd be Element of Fin dom App CFes st S = Sd holds
       M.((M "**" App CE1).s1,(M "**" App CE2).s2)= A$$(Sd,M"**"App CFes) &
       for h be FinSequence,i st h in Sd & i in dom h holds
         ((s1^s2).i = 1+len f implies h.i in {1+len f,2+len f}) &
         ((s1^s2).i <> 1+len f implies h.i =(s1^s2).i);

theorem :: HILB10_7:127
  A is commutative associative having_a_unity having_an_inverseOp &
  M is associative commutative having_a_unity &
  M is_distributive_wrt A
implies
  for E1 be Enumeration of F1 st union F1 c= Seg (1+m)
    for Ee be Enumeration of Ext(F1,1+m,2+m) st
        Ee = Ext(E1,1+m,2+m)
    ex S be Subset of doms(m+2,card F1) st
      S = (len E1)-tuples_on {1+m,2+m} &
      for CFe be non-empty non empty FinSequence of D*,f,d1,d2 st
        len f=m &
        CFe = SignGenOp(f^<*d1*>^<*d2*>,A,Ext(F1,1+len f,2+len f) ) * Ee
      for Sd be Element of Fin dom App CFe st Sd = S holds
      (M "**" App (SignGenOp(f^<*A .(d1,d2)*>,A,F1)*E1)).(len E1|->(1+ len f))
        = A$$(Sd,M"**"App CFe);

theorem :: HILB10_7:128
  A is commutative associative having_a_unity having_an_inverseOp
implies
  for E1 be Enumeration of F1 st union F1 c= Seg (1+len f)
    for Ee be Enumeration of Ext(F1,1+len f,2+len f),
        Es be Enumeration of swap(F1,1+len f,2+len f) st
        Ee = Ext(E1,1+len f,2+len f) & Es = Swap(E1,1+len f,2+len f)
for CFe be non-empty non empty FinSequence of D*,
    CFs be non-empty non empty FinSequence of D* st
   CFe = SignGenOp(f^<*d1*>^<*d2*>,A, Ext(F1,1+len f,2+len f) ) * Ee &
   CFs = SignGenOp(f^<*(the_inverseOp_wrt A).d1*>^<*d2*>,
     A, swap(F1,1+len f,2+len f) ) * Es
for S1 be Element of Fin dom App CFe,S2 be Element of Fin dom App CFs st
  S1=S2 holds
A$$(S1,M"**"App CFe) = A$$(S2,M"**"App CFs);

theorem :: HILB10_7:129
   A is commutative associative having_a_unity having_an_inverseOp &
    M is associative commutative having_a_unity &
   M is_distributive_wrt A implies
for E1 be Enumeration of F1 st union F1 c= Seg (1+m)
    for Es be Enumeration of swap(F1,1+m,2+m) st
        Es = Swap(E1,1+m,2+m)
ex S be Subset of doms(m+2,card F1) st
    S = (len E1)-tuples_on {1+m,2+m} &
    for CFs be non-empty non empty FinSequence of D*,f,d1,d2 st
        len f=m &
        CFs = SignGenOp(f^<*d1*>^<*d2*>,A, swap(F1,1+len f,2+len f) ) * Es
    for Sd be Element of Fin dom App CFs st Sd=S
  holds
(M "**" App (SignGenOp(f^<*A . ((the_inverseOp_wrt A).d1,d2)*>,A,F1) * E1))
    .(len E1|-> (1+ len f))
    = A$$(Sd,M"**"App CFs);

theorem :: HILB10_7:130
   A is having_a_unity associative commutative having_an_inverseOp &
   M is commutative associative & len f <> 0
implies
  SignGenOp(f^<*d1*>^<*d2*>,M,A,Seg (2+len f)\{1}) =
    M.(SignGenOp(f^<*A.(d1,d2)*>,M,A,Seg (1+len f)\{1}),
     SignGenOp(f^<*A.((the_inverseOp_wrt A).d1,d2)*>,M,A,Seg (1+len f)\{1}));

theorem :: HILB10_7:131
   for E be Enumeration of F st union F c= Seg (1+len f)
      for Ee be Enumeration of Ext(F,1+len f,2+len f) st
          Ee = Ext(E,1+len f,2+len f)
       for CE1,CEE be FinSequence of D* st
          CE1 = SignGenOp(f^<*d*>,A,F) * E &
          CEE = SignGenOp(f^<*d1*>^<*d2*>,A,Ext(F,1+len f,2+len f)) * Ee
       for s be FinSequence st s in doms CE1 & rng s c= dom f holds
           s in doms CEE & (App CE1).s = (App CEE).s;

theorem :: HILB10_7:132
   for E be Enumeration of F st union F c= Seg (1+len f)
      for Es be Enumeration of swap(F,1+len f,2+len f) st
          Es = Swap(E,1+len f,2+len f)
       for CE1,CES be FinSequence of D* st
          CE1 = SignGenOp(f^<*d*>,A,F) * E &
          CES = SignGenOp(f^<*d1*>^<*d2*>,A,swap(F,1+len f,2+len f)) * Es
       for s be FinSequence st s in doms CE1 & rng s c= dom f holds
           s in doms CES & (App CE1).s = (App CES).s;

theorem :: HILB10_7:133
  for E1 be Enumeration of F1
    for CE1,CE2 be D*-valued FinSequence st
      CE1 = SignGenOp(f^<*d1*>,A,F1) * E1 &
      CE2 = SignGenOp(f^<*d2*>,A,F1) * E1
    for s be FinSequence st s in doms CE1 & not 1+len f in rng s holds
      s in doms CE2 & (App CE1).s = (App CE2).s;

theorem :: HILB10_7:134
  for s be FinSequence st card (s"{y})=k
    ex p be Permutation of dom s,s1 be FinSequence st
      s*p = s1^(k|->y) & not y in rng s1;

theorem :: HILB10_7:135
  for f be FinSequence of D st
    A is commutative associative having_a_unity having_an_inverseOp &
    M is associative commutative having_a_unity &
    M is_distributive_wrt A & n in dom f holds
  for E be Enumeration of F
    for D be Subset of dom E st (for i holds i in D iff n in E.i) holds
      (card D is even implies
        (M "**" (App (SignGenOp(f,A,F) * E))).(len E |-> n) =
         M "**" (len E |-> f/.n)) &
       (card D is odd implies
         (M "**" (App (SignGenOp(f,A,F) * E))).(len E |-> n) =
         (the_inverseOp_wrt A).(M "**" (len E |-> f/.n)));

theorem :: HILB10_7:136
    M is commutative associative having_a_unity &
    A is commutative associative having_a_unity having_an_inverseOp &
    M is_distributive_wrt A  implies
for f be FinSequence of D
  for E1 be Enumeration of F1, E2 be Enumeration of F2
    for s1,s2 be FinSequence st
       s1 in doms (SignGenOp(f^<*d1*>,A,F1) * E1) &
       s2 in doms (SignGenOp(f^<*d2*>,A,F2) * E2) &
       card (s1"{1+len f}) = card (s2"{1+len f})
holds
  M.((M "**" App (SignGenOp(f^<*d1*>,A,F1) * E1)).s1,
   (M "**" App (SignGenOp(f^<*d2*>,A,F2) * E2)).s2) =
  M.((M "**" App (SignGenOp(f^<*d2*>,A,F1) * E1)).s1,
   (M "**" App (SignGenOp(f^<*d1*>,A,F2) * E2)).s2);

theorem :: HILB10_7:137
    M is commutative associative having_a_unity &
    A is commutative associative having_a_unity having_an_inverseOp &
    M is_distributive_wrt A  implies
 for E1 be Enumeration of F1 st union F1 c= Seg (1+m) & len E1 is even
     for Ee be Enumeration of Ext(F1,1+m,2+m),
         Es be Enumeration of swap(F1,1+m,2+m) st
         Ee = Ext(E1,1+m,2+m) & Es = Swap(E1,1+m,2+m)
  ex se,ss be Subset of doms(m+2,card F1) st
    se c= (len E1)-tuples_on {1+m,2+m} &
    ss c= (len E1)-tuples_on {1+m,2+m} &
    se is with_evenly_repeated_values-member &
    ss is with_evenly_repeated_values-member &
  for CFe,CFs be non-empty non empty FinSequence of D*,f,d1,d2 st
       len f=m &
       CFe = SignGenOp(f^<*d1*>^<*d2*>,A, Ext(F1,1+len f,2+len f) ) * Ee &
      CFs = SignGenOp(f^<*d1*>^<*d2*>,A, swap(F1,1+len f,2+len f) ) * Es
  for Se be Element of Fin dom App CFe,
     Ss be Element of Fin dom App CFs st
  Se = se & Ss  = ss holds
  A. ((M "**" App (SignGenOp(f^<*A . (d1,d2)*>,A,F1) * E1)).
    (len E1|-> (1+ len f)),
    (M "**" App (SignGenOp(f^<*A.( (the_inverseOp_wrt A).d1,d2)*>,A,F1)* E1))
         .(len E1|-> (1+ len f))) =
  A. ( A$$(Se,M"**"App CFe), A$$(Ss,M"**"App CFs));

theorem :: HILB10_7:138
  A is commutative associative having_a_unity having_an_inverseOp &
  M is associative commutative having_a_unity &
  M is_distributive_wrt A
implies
  for E be Enumeration of F st union F c= Seg (1+m)
  for Ee be Enumeration of Ext(F,1+m,2+m),
      Es be Enumeration of swap(F,1+m,2+m) st
      Ee = Ext(E,1+m,2+m) & Es = Swap(E,1+m,2+m)
  for Ees be Enumeration of
      Ext(F,1+m,2+m)\/swap(F,1+m,2+m) st Ees=Ee^Es
  for s1,s2 be FinSequence st s1 in doms(m+1,card F) & s2 in doms(m+1,card F) &
    s1 is with_evenly_repeated_values & s2 is with_evenly_repeated_values &
    card (s1"{1+m}) < card (s2"{1+m})
  ex D1,D2 be Subset of doms(m+2,card F+card F) st
    D1 is with_evenly_repeated_values-member &
    D2 is with_evenly_repeated_values-member &
    for CE1,CE2 be FinSequence of D*,f,d1,d2 st
      len f = m &
      CE1 = SignGenOp(f^<*A . (d1,d2)*>,A,F) * E &
      CE2 = SignGenOp(f^<*A.( (the_inverseOp_wrt A).d1,d2)*>,A,F) * E
     for CFes be non-empty non empty FinSequence of D* st
       CFes = SignGenOp(f^<*d1*>^<*d2*>,A,
             Ext(F,1+len f,2+len f)\/swap(F,1+len f,2+len f) ) * Ees
     for S1,S2 be Element of Fin dom App CFes st
       S1=D1 & S2=D2 holds
     S1 misses S2 &
     A.(M.((M"**"App CE1).s1,(M"**"App CE2).s2),
        M.((M"**"App CE1).s2,(M"**"App CE2).s1))= A$$(S1\/S2,M"**"App CFes) &
     (for h be FinSequence,i st h in S1 & i in dom (s1^s2) holds
       ((s1^s2).i = 1+len f implies h.i in {1+len f,2+len f}) &
       ((s1^s2).i <> 1+len f implies h.i =(s1^s2).i)) &
     (for h be FinSequence,i st h in S2 & i in dom (s2^s1) holds
       ((s2^s1).i = 1+len f implies h.i in {1+len f,2+len f}) &
       ((s2^s1).i <> 1+len f implies h.i =(s2^s1).i));

theorem :: HILB10_7:139
  A is commutative associative having_a_unity having_an_inverseOp &
  M is associative commutative having_a_unity &
  M is_distributive_wrt A
implies
  for E be Enumeration of F st union F c= Seg (1+m)
  for Ee be Enumeration of Ext(F,1+m,2+m),
      Es be Enumeration of swap(F,1+m,2+m) st
      Ee = Ext(E,1+m,2+m) & Es = Swap(E,1+m,2+m)
  for Ees be Enumeration of
      Ext(F,1+m,2+m)\/swap(F,1+m,2+m) st Ees=Ee^Es
  for s1,s2 be FinSequence st s1 in doms(m+1,card F) & s2 in doms(m+1,card F) &
    s1 is with_evenly_repeated_values & s2 is with_evenly_repeated_values &
    s1<>s2
  ex D1,D2 be Subset of doms(m+2,card F+card F) st
    D1 is with_evenly_repeated_values-member &
    D2 is with_evenly_repeated_values-member &
    for CE1,CE2 be FinSequence of D*,f,d1,d2 st
      len f = m &
      CE1 = SignGenOp(f^<*A . (d1,d2)*>,A,F) * E &
      CE2 = SignGenOp(f^<*A.( (the_inverseOp_wrt A).d1,d2)*>,A,F) * E
     for CFes be non-empty non empty FinSequence of D* st
       CFes = SignGenOp(f^<*d1*>^<*d2*>,A,
             Ext(F,1+len f,2+len f)\/swap(F,1+len f,2+len f) ) * Ees
     for S1,S2 be Element of Fin dom App CFes st
       S1=D1 & S2=D2 holds
     S1 misses S2 &
     A.(M.((M"**"App CE1).s1,(M"**"App CE2).s2),
        M.((M"**"App CE1).s2,(M"**"App CE2).s1))= A$$(S1\/S2,M"**"App CFes) &
     (for h be FinSequence,i st h in S1 & i in dom (s1^s2) holds
       ((s1^s2).i = 1+len f implies h.i in {1+len f,2+len f}) &
       ((s1^s2).i <> 1+len f implies h.i =(s1^s2).i)) &
     (for h be FinSequence,i st h in S2 & i in dom (s2^s1) holds
       ((s2^s1).i = 1+len f implies h.i in {1+len f,2+len f}) &
       ((s2^s1).i <> 1+len f implies h.i =(s2^s1).i));

theorem :: HILB10_7:140
  M is commutative associative & len f=2
implies
  SignGenOp(f,M,A,{2}) = M.(A.(f.1,f.2), A.(f.1,(the_inverseOp_wrt A).(f.2)));


theorem :: HILB10_7:141
  M is commutative associative &
  A is commutative associative having_a_unity having_an_inverseOp &
  M is_distributive_wrt A
implies
  for E be Enumeration of bool {2}
    for CE be non-empty non empty FinSequence of D* st
      CE = SignGenOp(f,A,bool {2}) * E & len f = 2
      ex S be Element of Fin dom App CE st S = { <*1,1*>, <*2,2*>} &
        SignGenOp(f,M,A,{2}) = A $$ (S,M "**" App CE);

theorem :: HILB10_7:142
   M is commutative associative &
   A is commutative associative having_a_unity having_an_inverseOp &
   M is_distributive_wrt A
implies
  for E be Enumeration of bool {2}
    for CE be non-empty non empty FinSequence of D* st
        CE = SignGenOp(f,A,bool {2}) * E & len f = 2
     ex S be Element of Fin dom App CE st
        S is with_evenly_repeated_values-member &
       SignGenOp(f,M,A,{2}) = A $$ (S,M "**" App CE);

::$N Main Theorem

theorem :: HILB10_7:143
  A is commutative associative having_a_unity having_an_inverseOp &
  M is associative commutative having_a_unity &
  M is_distributive_wrt A & m > 1 &
  (for d holds M.(the_unity_wrt A,d) = the_unity_wrt A)
implies
     ex E be Enumeration of bool(Seg m\{1}),
        S be Subset of doms(m,card bool(Seg m\{1})) st
       S is with_evenly_repeated_values-member &
       card bool(Seg m\{1}) |-> 1 in S &
       for CE be non-empty non empty FinSequence of D*,f st
          CE = SignGenOp(f,A,bool(Seg m\{1})) * E & len f = m
          for Sce be Element of Fin dom App CE st Sce=S holds
             SignGenOp(f,M,A,Seg m\{1}) = A $$ (Sce,M "**" App CE);
