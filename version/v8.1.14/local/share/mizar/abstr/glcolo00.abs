:: Introduction to Graph Colorings
::  by Sebastian Koch
::
:: Received July 23, 2022
:: Copyright (c) 2022-2023 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, RELAT_1, FUNCT_1, XXREAL_0, TARSKI, ARYTM_3,
      CARD_1, XBOOLE_0, NAT_1, ARYTM_1, GLIB_000, PARTFUN1, FINSET_1, ZFMISC_1,
      FUNCOP_1, GLIB_009, MOD_4, GLIB_006, GLIB_007, FUNCT_4, CARD_2, SCMYCIEL,
      GLIB_010, SIMPLEX0, XCMPLX_0, MCART_1, SETFAM_1, FACIRC_1, ORDINAL1,
      PBOOLE, CHORD, RING_3, REWRITE1, GLIB_013, GLCOLO00;
 notations TARSKI, XBOOLE_0, XTUPLE_0, ZFMISC_1, SUBSET_1, SETFAM_1, RELAT_1,
      FUNCT_1, ORDINAL1, RELSET_1, PARTFUN1, WELLORD2, FUNCT_2, BINOP_1,
      DOMAIN_1, FUNCT_3, FUNCOP_1, FUNCT_4, FINSET_1, CARD_1, PBOOLE, PARTFUN2,
      CARD_3, NUMBERS, XCMPLX_0, XXREAL_0, XREAL_0, NAT_1, INT_1, VALUED_0,
      NAT_D, CARD_2, FINSEQ_1, EQREL_1, FINSEQ_2, NEWTON, FUNCT_7, GLIB_000,
      STRUCT_0, ALGSTR_0, ORDERS_2, GROUP_1, GROUP_2, GROUP_6, YELLOW_1,
      SGRAPH1, MATRIX11, GLIB_001, CHORD, AOFA_I00, GLIB_006, GLIB_007,
      GLIB_008, GLIB_009, GLIB_010, GLIB_013;
 constructors DOMAIN_1, FUNCT_4, XXREAL_0, NAT_1, NAT_D, BINOP_2, CARD_2,
      FINSEQ_4, PBOOLE, ORDINAL3, WELLORD2, PARTFUN1, RELSET_1, GLIB_000,
      STRUCT_0, RELAT_1, FUNCT_1, FUNCT_2, ALGSTR_0, GROUP_1, GLIB_001, ABIAN,
      CARD_3, FINSEQ_1, GLIB_002, GLIB_003, SETFAM_1, EQREL_1, GROUP_2,
      GROUP_6, GLIB_006, GLIB_007, PARTFUN2, CHORD, XTUPLE_0, MATRIX11,
      GLIB_008, FUNCT_7, GLIB_009, GLIB_010, SQUARE_1, NEWTON, YELLOW_1,
      VALUED_0, SGRAPH1, ORDERS_2, AOFA_I00, GLIB_013, FUNCT_3;
 registrations XBOOLE_0, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1, FINSET_1,
      NUMBERS, XREAL_0, NAT_1, MEMBERED, FINSEQ_1, GLIB_000, GLIB_002,
      GLIB_003, INT_1, VALUED_0, CARD_1, FUNCT_2, PARTFUN1, RELSET_1, XTUPLE_0,
      CARD_3, GROUP_1, STRUCT_0, GLIB_001, ABIAN, FINSEQ_4, GROUP_2, GLIB_006,
      EQREL_1, GLIB_007, GLIB_008, CHORD, NECKLACE, FUNCT_7, GLIB_009,
      MATRIX11, GLIB_010, SQUARE_1, NEWTON, SETFAM_1, FINSEQ_2, CARD_2,
      GLIB_012, RAMSEY_1, MSAFREE5, GRFUNC_1, SGRAPH1, CARD_5, FUNCT_4,
      WELLORD2, GLIBPRE0, YELLOW_1, ORDINAL7, RVSUM_4, AOFA_I00, GLIB_013,
      FUNCT_3, GLIBPRE1;
 requirements ARITHM, BOOLE, NUMERALS, REAL, SUBSET;


begin :: Vertex Colorings

reserve E,V for set, G,G1,G2 for _Graph, c,c1,c2 for Cardinal, n for Nat;

definition
  let G;
  mode VColoring of G is ManySortedSet of the_Vertices_of G;
end;

registration
  let G;
  cluster -> non empty for VColoring of G;
end;

reserve f for VColoring of G;

theorem :: GLCOLO00:1
  for f9 being Function st rng f c= dom f9 holds f9*f is VColoring of G;

definition
  let G, f; let f9 be ManySortedSet of rng f;
  redefine func f9*f -> VColoring of G;
end;

:: might need Proof outside this article
theorem :: GLCOLO00:2
  for v being Vertex of G, x being object holds f+*(v.-->x) is VColoring of G;

theorem :: GLCOLO00:3
  for H being Subgraph of G holds f | the_Vertices_of H is VColoring of H;

theorem :: GLCOLO00:4
  for G1 being addVertices of G2, V, f being VColoring of G2
  for h being Function st dom h = V \ the_Vertices_of G2
  holds f +* h is VColoring of G1;

:: since the vertices do not change for addEdge, no extra theorem is provided

theorem :: GLCOLO00:5
  for v,e,x being object, w being Vertex of G2
  for G1 being addAdjVertex of G2,v,e,w, f being VColoring of G2
  st not e in the_Edges_of G2 & not v in the_Vertices_of G2
  holds f +* (v .--> x) is VColoring of G1;

theorem :: GLCOLO00:6
  for v being Vertex of G2, e,w,x being object
  for G1 being addAdjVertex of G2,v,e,w, f being VColoring of G2
  st not e in the_Edges_of G2 & not w in the_Vertices_of G2
  holds f +* (w .--> x) is VColoring of G1;

theorem :: GLCOLO00:7
  for v,x being object, V being Subset of the_Vertices_of G2
  for G1 being addAdjVertexAll of G2,v,V, f2 being VColoring of G2
  st not v in the_Vertices_of G2 holds f2+*(v.-->x) is VColoring of G1;

theorem :: GLCOLO00:8
  for F being PGraphMapping of G1,G st dom F_V = the_Vertices_of G1
  holds f*F_V is VColoring of G1;

theorem :: GLCOLO00:9
  for F being PGraphMapping of G1,G st F is total
  holds f*F_V is VColoring of G1;

definition
  let G, f;
  attr f is proper means
:: GLCOLO00:def 1
  for v,w being Vertex of G st v,w are_adjacent holds f.v <> f.w;
end;

theorem :: GLCOLO00:10
  f is proper iff for e,v,w being object st e Joins v,w,G holds f.v <> f.w;

theorem :: GLCOLO00:11
  f is proper iff for e,v,w being object st e DJoins v,w,G holds f.v <> f.w;

theorem :: GLCOLO00:12
  for f9 being one-to-one Function, f2 being VColoring of G
  st f2 = f9*f & f is proper & rng f c= dom f9 holds f2 is proper;

theorem :: GLCOLO00:13
  for f9 being one-to-one ManySortedSet of rng f
  holds f is proper implies f9*f is proper;

theorem :: GLCOLO00:14
  (ex f st f is proper) implies G is loopless;

registration
  let G be non loopless _Graph;
  cluster -> non proper for VColoring of G;
end;

registration
  let G be loopless _Graph;
  cluster one-to-one -> proper for VColoring of G;
end;

registration
  let G be loopless _Graph;
  cluster one-to-one proper for VColoring of G;
end;

theorem :: GLCOLO00:15
  for H being Subgraph of G, f9 being VColoring of H
  st f9 = f | the_Vertices_of H & f is proper holds f9 is proper;

theorem :: GLCOLO00:16
  for f1 being VColoring of G1, f2 being VColoring of G2
  st G1 == G2 & f1 = f2 & f1 is proper holds f2 is proper;

theorem :: GLCOLO00:17
  for f1 being VColoring of G1, f2 being VColoring of G2
  for v being Vertex of G1, x being object
  st G1 == G2 & f2 = f1 +* (v .--> x) & not x in rng f1 & f1 is proper
  holds f2 is proper;

theorem :: GLCOLO00:18
  for G2 being reverseEdgeDirections of G1, E
  for f1 being VColoring of G1, f2 being VColoring of G2
  st f1 = f2 holds f1 is proper iff f2 is proper;

theorem :: GLCOLO00:19
  for G1 being addVertices of G2, V
  for f1 being VColoring of G1, f2 being VColoring of G2, h being Function
  st dom h = V \ the_Vertices_of G2 & f1 = f2 +* h & f2 is proper
  holds f1 is proper;

theorem :: GLCOLO00:20
  for v,w being Vertex of G2, e being object, G1 being addEdge of G2,v,e,w
  for f1 being VColoring of G1, f2 being VColoring of G2
  st f1 = f2 & v,w are_adjacent & f2 is proper holds f1 is proper;

theorem :: GLCOLO00:21
  for v being Vertex of G2, e,w being object, G1 being addEdge of G2,v,e,w
  for f1 being VColoring of G1, f2 being VColoring of G2, x being object
  st f1=f2+*(v.-->x) & v<>w & not x in rng f2 & f2 is proper holds f1 is proper
;

theorem :: GLCOLO00:22
  for v,e being object, w being Vertex of G2, G1 being addEdge of G2,v,e,w
  for f1 being VColoring of G1, f2 being VColoring of G2, x being object
  st f1=f2+*(w.-->x) & v<>w & not x in rng f2 & f2 is proper holds f1 is proper
;

theorem :: GLCOLO00:23
  for v,e,w being object, G1 being addAdjVertex of G2,v,e,w
  for f1 being VColoring of G1, f2 being VColoring of G2, x being object
  st not v in the_Vertices_of G2 & f1 = f2 +* (v .--> x) & x <> f2.w
  holds f2 is proper implies f1 is proper;

theorem :: GLCOLO00:24
  for v,e,w being object, G1 being addAdjVertex of G2,v,e,w
  for f1 being VColoring of G1, f2 being VColoring of G2, x being object
  st not w in the_Vertices_of G2 & f1 = f2 +* (w .--> x) & x <> f2.v
  holds f2 is proper implies f1 is proper;

theorem :: GLCOLO00:25
  for v,x being object, V being Subset of the_Vertices_of G2
  for G1 being addAdjVertexAll of G2,v,V
  for f1 being VColoring of G1, f2 being VColoring of G2
  st not v in the_Vertices_of G2 & f1=f2+*(v.-->x) & not x in rng f2
  holds f2 is proper implies f1 is proper;

theorem :: GLCOLO00:26
  for F being PGraphMapping of G1,G, f9 being VColoring of G1
  st F is total & f9 = f*F_V & f is proper holds f9 is proper;

definition
  let c, G;
  attr G is c-vcolorable means
:: GLCOLO00:def 2
  ex f being VColoring of G st f is proper & card rng f c= c;
end;

theorem :: GLCOLO00:27
  c1 c= c2 & G is c1-vcolorable implies G is c2-vcolorable;

:: might need Proof outside this article
theorem :: GLCOLO00:28
  (ex c st G is c-vcolorable) implies G is loopless;

registration
  let c;
  cluster c-vcolorable -> loopless for _Graph;
  cluster loopless c-vertex -> c-vcolorable for _Graph;
end;

registration
  cluster -> non 0-vcolorable for _Graph;
end;

theorem :: GLCOLO00:29
  G is loopless implies G is G.order()-vcolorable;

theorem :: GLCOLO00:30
  G is edgeless iff G is 1-vcolorable;

registration
  let c be non zero Cardinal;
  cluster c-vcolorable for _Graph;
end;

theorem :: GLCOLO00:31
  for H being Subgraph of G holds G is c-vcolorable implies H is c-vcolorable;

registration
  cluster edgeless -> 1-vcolorable for _Graph;
  cluster 1-vcolorable -> edgeless for _Graph;
  let c be non zero Cardinal;
  let G be c-vcolorable _Graph;
  cluster -> c-vcolorable for Subgraph of G;
end;

theorem :: GLCOLO00:32
  G1 == G2 & G1 is c-vcolorable implies G2 is c-vcolorable;

theorem :: GLCOLO00:33
  for G2 being reverseEdgeDirections of G1, E
  holds G1 is c-vcolorable iff G2 is c-vcolorable;

registration
  let c be non zero Cardinal;
  let G1 be c-vcolorable _Graph;
  let E;
  cluster -> c-vcolorable for reverseEdgeDirections of G1, E;
end;

theorem :: GLCOLO00:34
  for G1 being addVertices of G2, V
  holds G1 is c-vcolorable iff G2 is c-vcolorable;

registration
  let c be non zero Cardinal;
  let G2 be c-vcolorable _Graph;
  let V;
  cluster -> c-vcolorable for addVertices of G2, V;
end;

theorem :: GLCOLO00:35
  for v,w being Vertex of G2, e being object, G1 being addEdge of G2,v,e,w
  st v,w are_adjacent holds G1 is c-vcolorable iff G2 is c-vcolorable;

theorem :: GLCOLO00:36
  for v,e,w being object, G1 being addEdge of G2,v,e,w
  st v <> w & G2 is c-vcolorable holds G1 is (c+`1)-vcolorable;

theorem :: GLCOLO00:37
  for G2 being non edgeless _Graph, v,e,w being object
  for G1 being addAdjVertex of G2,v,e,w
  holds G1 is c-vcolorable iff G2 is c-vcolorable;

theorem :: GLCOLO00:38
  for G2 being edgeless _Graph, v,e,w being object
  for G1 being addAdjVertex of G2,v,e,w holds G1 is 2-vcolorable;

theorem :: GLCOLO00:39
  for v being object, G1 being addAdjVertexAll of G2,v,V
  st G2 is c-vcolorable holds G1 is (c+`1)-vcolorable;

theorem :: GLCOLO00:40
  for G2 being removeParallelEdges of G1
  holds G1 is c-vcolorable iff G2 is c-vcolorable;

registration
  let c be non zero Cardinal;
  let G1 be c-vcolorable _Graph;
  cluster -> c-vcolorable for removeParallelEdges of G1;
end;

theorem :: GLCOLO00:41
  for G2 being removeDParallelEdges of G1
  holds G1 is c-vcolorable iff G2 is c-vcolorable;

registration
  let c be non zero Cardinal;
  let G1 be c-vcolorable _Graph;
  cluster -> c-vcolorable for removeDParallelEdges of G1;
end;

theorem :: GLCOLO00:42
  for F being PGraphMapping of G1, G2
  st F is weak_SG-embedding & G2 is c-vcolorable holds G1 is c-vcolorable;

theorem :: GLCOLO00:43
  for F being PGraphMapping of G1, G2
  st F is isomorphism holds G1 is c-vcolorable iff G2 is c-vcolorable;

registration
  let c be non zero Cardinal;
  let G be c-vcolorable _Graph;
  cluster G-isomorphic -> c-vcolorable for _Graph;
end;

definition
  let G;
  attr G is finite-vcolorable means
:: GLCOLO00:def 3 :: or finitely-vcolorable

  ex n st G is n-vcolorable;
end;

registration
  cluster finite-vcolorable -> loopless for _Graph;
  cluster vertex-finite loopless -> finite-vcolorable for _Graph;
  cluster edgeless -> finite-vcolorable for _Graph;
  let n;
  cluster n-vcolorable -> finite-vcolorable for _Graph;
end;

registration
  cluster finite-vcolorable for _Graph;
  cluster non finite-vcolorable for _Graph;
end;

registration
  let G be finite-vcolorable _Graph;
  cluster -> finite-vcolorable for Subgraph of G;
end;

registration
  let G be non finite-vcolorable _Graph;
  cluster -> non finite-vcolorable for Supergraph of G;
end;

theorem :: GLCOLO00:44
  G1 == G2 & G1 is finite-vcolorable implies G2 is finite-vcolorable;

theorem :: GLCOLO00:45
  for G2 being reverseEdgeDirections of G1, E
  holds G1 is finite-vcolorable iff G2 is finite-vcolorable;

registration
  let G1 be finite-vcolorable _Graph; let E;
  cluster -> finite-vcolorable for reverseEdgeDirections of G1, E;
end;

registration
  let G1 be non finite-vcolorable _Graph; let E;
  cluster -> non finite-vcolorable for reverseEdgeDirections of G1, E;
end;

theorem :: GLCOLO00:46
  for G1 being addVertices of G2, V
  holds G1 is finite-vcolorable iff G2 is finite-vcolorable;

registration
  let G2 be finite-vcolorable _Graph; let V;
  cluster -> finite-vcolorable for addVertices of G2, V;
end;

theorem :: GLCOLO00:47
  for v,e,w being object, G1 being addEdge of G2,v,e,w st v <> w
  holds G1 is finite-vcolorable iff G2 is finite-vcolorable;

theorem :: GLCOLO00:48
  for v,e,w being object, G1 being addAdjVertex of G2,v,e,w
  holds G1 is finite-vcolorable iff G2 is finite-vcolorable;

registration
  let G2 be finite-vcolorable _Graph, v,e,w be object;
  cluster -> finite-vcolorable for addAdjVertex of G2,v,e,w;
end;

theorem :: GLCOLO00:49
  for v being object, G1 being addAdjVertexAll of G2,v,V
  holds G1 is finite-vcolorable iff G2 is finite-vcolorable;

registration
  let G2 be finite-vcolorable _Graph, v be object; let V;
  cluster -> finite-vcolorable for addAdjVertexAll of G2,v,V;
end;

theorem :: GLCOLO00:50
  for G2 being removeParallelEdges of G1
  holds G1 is finite-vcolorable iff G2 is finite-vcolorable;

registration
  let G1 be non finite-vcolorable _Graph;
  cluster -> non finite-vcolorable for removeParallelEdges of G1;
end;

theorem :: GLCOLO00:51
  for G2 being removeDParallelEdges of G1
  holds G1 is finite-vcolorable iff G2 is finite-vcolorable;

registration
  let G1 be non finite-vcolorable _Graph;
  cluster -> non finite-vcolorable for removeDParallelEdges of G1;
end;

theorem :: GLCOLO00:52
  for F being PGraphMapping of G1,G2
  st F is weak_SG-embedding & G2 is finite-vcolorable
  holds G1 is finite-vcolorable;

theorem :: GLCOLO00:53
  for F being PGraphMapping of G1, G2 st F is isomorphism
  holds G1 is finite-vcolorable iff G2 is finite-vcolorable;

registration
  let G be finite-vcolorable _Graph;
  cluster G-isomorphic -> finite-vcolorable for _Graph;
end;

definition
  let G be _Graph;
  func G.vChromaticNum() -> Cardinal equals
:: GLCOLO00:def 4 :: chi
  meet { c where c is cardinal Subset of G.order() : G is c-vcolorable };
end;

theorem :: GLCOLO00:54
  G is loopless implies G is G.vChromaticNum()-vcolorable;

theorem :: GLCOLO00:55
  G is non loopless iff G.vChromaticNum() = 0;

registration
  let G be loopless _Graph;
  cluster G.vChromaticNum() -> non zero;
end;

registration
  let G be non loopless _Graph;
  cluster G.vChromaticNum() -> zero;
end;

theorem :: GLCOLO00:56
  G.vChromaticNum() c= G.order();

theorem :: GLCOLO00:57
  G is c-vcolorable implies G.vChromaticNum() c= c;

theorem :: GLCOLO00:58
  (G is c-vcolorable & for d being Cardinal st G is d-vcolorable holds c c= d)
  implies G.vChromaticNum() = c;

registration
  let G be finite-vcolorable _Graph;
  cluster G.vChromaticNum() -> natural;
end;

definition
  let G be finite-vcolorable _Graph;
  redefine func G.vChromaticNum() -> Nat;
end;

theorem :: GLCOLO00:59
  for G being loopless _Graph holds 1 c= G.vChromaticNum();

theorem :: GLCOLO00:60
  G is edgeless iff G.vChromaticNum() = 1;

theorem :: GLCOLO00:61
  for G being loopless non edgeless _Graph holds 2 c= G.vChromaticNum();

theorem :: GLCOLO00:62
  for G being loopless _Graph
  holds G is complete implies G.vChromaticNum() = G.order();

theorem :: GLCOLO00:63
  for G being loopless _Graph, H being Subgraph of G
  holds H.vChromaticNum() c= G.vChromaticNum();

theorem :: GLCOLO00:64
  G1 == G2 implies G1.vChromaticNum() = G2.vChromaticNum();

theorem :: GLCOLO00:65
  for G2 being reverseEdgeDirections of G1, E
  holds G1.vChromaticNum() = G2.vChromaticNum();

theorem :: GLCOLO00:66
  for G1 being addVertices of G2, V
  holds G1.vChromaticNum() = G2.vChromaticNum();

theorem :: GLCOLO00:67
  for G2 being non edgeless _Graph, v,e,w being object
  for G1 being addAdjVertex of G2,v,e,w
  holds G1.vChromaticNum() = G2.vChromaticNum();

theorem :: GLCOLO00:68
  for G2 being edgeless _Graph, v being Vertex of G2, e,w being object
  for G1 being addAdjVertex of G2,v,e,w
  st not w in the_Vertices_of G2 holds G1.vChromaticNum() = 2;

theorem :: GLCOLO00:69
  for G2 being edgeless _Graph, v,e being object, w being Vertex of G2
  for G1 being addAdjVertex of G2,v,e,w
  st not v in the_Vertices_of G2 holds G1.vChromaticNum() = 2;

theorem :: GLCOLO00:70
  for v being object, G1 being addAdjVertexAll of G2,v,V
  holds G1.vChromaticNum() c= G2.vChromaticNum() +` 1;

theorem :: GLCOLO00:71
  for G2 being loopless _Graph, v being object
  for G1 being addAdjVertexAll of G2,v st not v in the_Vertices_of G2
  holds G1.vChromaticNum() = G2.vChromaticNum() +` 1;

theorem :: GLCOLO00:72
  for G2 being removeParallelEdges of G1
  holds G1.vChromaticNum() = G2.vChromaticNum();

theorem :: GLCOLO00:73
  for G2 being removeDParallelEdges of G1
  holds G1.vChromaticNum() = G2.vChromaticNum();

theorem :: GLCOLO00:74
  for G1 being _Graph, G2 being loopless _Graph
  for F being PGraphMapping of G1, G2 st F is weak_SG-embedding
  holds G1.vChromaticNum() c= G2.vChromaticNum();

theorem :: GLCOLO00:75
  for F being PGraphMapping of G1, G2
  st F is isomorphism holds G1.vChromaticNum() = G2.vChromaticNum();

theorem :: GLCOLO00:76
  for G2 being G1-isomorphic _Graph
  holds G1.vChromaticNum() = G2.vChromaticNum();

begin :: Edge Colorings

definition
  let G;
  mode EColoring of G is ManySortedSet of the_Edges_of G;
end;

reserve g for EColoring of G;

theorem :: GLCOLO00:77
  for g9 being Function st rng g c= dom g9 holds g9*g is EColoring of G;

definition
  let G, g; let g9 be ManySortedSet of rng g;
  redefine func g9*g -> EColoring of G;
end;

theorem :: GLCOLO00:78
  for H being Subgraph of G holds g | the_Edges_of H is EColoring of H;

theorem :: GLCOLO00:79
  for e being object, v,w being Vertex of G2, G1 being addEdge of G2,v,e,w
  for g being EColoring of G2, x being object st not e in the_Edges_of G2
  holds g +* (e .--> x) is EColoring of G1;

theorem :: GLCOLO00:80
  for v,e being object, w being Vertex of G2, G1 being addAdjVertex of G2,v,e,w
  for g being EColoring of G2, x being object
  st not e in the_Edges_of G2 & not v in the_Vertices_of G2
  holds g +* (e .--> x) is EColoring of G1;

theorem :: GLCOLO00:81
  for v being Vertex of G2, e,w being object, G1 being addAdjVertex of G2,v,e,w
  for g being EColoring of G2, x being object
  st not e in the_Edges_of G2 & not w in the_Vertices_of G2
  holds g +* (e .--> x) is EColoring of G1;

theorem :: GLCOLO00:82
  for v being object, V being Subset of the_Vertices_of G2
  for G1 being addAdjVertexAll of G2,v,V, g2 being EColoring of G2
  for h being Function
  st not v in the_Vertices_of G2 & dom h = G1.edgesBetween(V,{v})
  holds g2+*h is EColoring of G1;

theorem :: GLCOLO00:83
  for F being PGraphMapping of G1,G st dom F_E = the_Edges_of G1
  holds g*(F_E) is EColoring of G1;

theorem :: GLCOLO00:84
  for F being PGraphMapping of G1,G st F is total
  holds g*(F_E) is EColoring of G1;

definition
  let G, g;
  attr g is proper means
:: GLCOLO00:def 5

  for v being Vertex of G holds g | v.edgesInOut() is one-to-one;
end;

theorem :: GLCOLO00:85
  g is proper iff for v being Vertex of G, e1, e2 being object
    st e1 in v.edgesInOut() & e2 in v.edgesInOut() & g.e1 = g.e2 holds e1 = e2;

theorem :: GLCOLO00:86
  g is proper iff for e1,e2,v,w1,w2 being object
    st e1 Joins v,w1,G & e2 Joins v,w2,G & g.e1 = g.e2 holds e1 = e2;

theorem :: GLCOLO00:87
  for g9 being one-to-one Function, g2 being EColoring of G
  st g2 = g9*g & g is proper holds g2 is proper;

theorem :: GLCOLO00:88
  for g9 being one-to-one ManySortedSet of rng g
  holds g is proper implies g9*g is proper;

registration
  let G;
  cluster one-to-one -> proper for EColoring of G;
end;

registration
  let G;
  cluster one-to-one proper for EColoring of G;
end;

theorem :: GLCOLO00:89
  for H being Subgraph of G, g9 being EColoring of H
  st g9 = g | the_Edges_of H & g is proper holds g9 is proper;

theorem :: GLCOLO00:90
  for g1 being EColoring of G1, g2 being EColoring of G2
  st G1 == G2 & g1 = g2 & g1 is proper holds g2 is proper;

theorem :: GLCOLO00:91
  for G2 being reverseEdgeDirections of G1, E
  for g1 being EColoring of G1, g2 being EColoring of G2
  st g1 = g2 holds g1 is proper iff g2 is proper;

theorem :: GLCOLO00:92
  for G1 being addVertices of G2, V
  for g1 being EColoring of G1, g2 being EColoring of G2 st g1 = g2
  holds g2 is proper implies g1 is proper;

theorem :: GLCOLO00:93
  for v,e,w being object, G1 being addEdge of G2,v,e,w
  for g1 being EColoring of G1, g2 being EColoring of G2, x being object
  st g1 = g2 +* (e .--> x) & not e in the_Edges_of G2 & not x in rng g2
  holds g2 is proper implies g1 is proper;

theorem :: GLCOLO00:94
  for v,e being object, w being Vertex of G2, G1 being addAdjVertex of G2,v,e,w
  for g1 being EColoring of G1, g2 being EColoring of G2, x being object
  st g1 = g2 +* (e .--> x) & not x in rng g2 &
    not e in the_Edges_of G2 & not v in the_Vertices_of G2
  holds g2 is proper implies g1 is proper;

theorem :: GLCOLO00:95
  for v being Vertex of G2, e,w being object, G1 being addAdjVertex of G2,v,e,w
  for g1 being EColoring of G1, g2 being EColoring of G2, x being object
  st g1 = g2 +* (e .--> x) & not x in rng g2 &
    not e in the_Edges_of G2 & not w in the_Vertices_of G2
  holds g2 is proper implies g1 is proper;

theorem :: GLCOLO00:96
  for v being object, V being Subset of the_Vertices_of G2
  for G1 being addAdjVertexAll of G2,v,V, g2 being EColoring of G2
  for g1 being EColoring of G1, X, E being set
  st E = G1.edgesBetween(V,{v}) & rng g2 c= X & g1 = g2+*<: E-->X, id E :> &
    not v in the_Vertices_of G2 & g2 is proper
  holds g1 is proper;

theorem :: GLCOLO00:97
  for F being PGraphMapping of G1,G, g9 being EColoring of G1
  st dom F_E = the_Edges_of G1 & F_E is one-to-one & g9 = g*(F_E) & g is proper
  holds g9 is proper;

theorem :: GLCOLO00:98
  for F being PGraphMapping of G1,G, g9 being EColoring of G1
  st F is weak_SG-embedding & g9 = g*(F_E) & g is proper holds g9 is proper;

definition
  let c, G;
  attr G is c-ecolorable means
:: GLCOLO00:def 6

  ex g being proper EColoring of G st card rng g c= c;
end;

theorem :: GLCOLO00:99
  c1 c= c2 & G is c1-ecolorable implies G is c2-ecolorable;

theorem :: GLCOLO00:100
  G is G.size()-ecolorable;

theorem :: GLCOLO00:101
  G is edgeless iff G is 0-ecolorable;

registration
  cluster edgeless -> 0-ecolorable for _Graph;
  cluster 0-ecolorable -> edgeless for _Graph;
  let c;
  cluster c-edge -> c-ecolorable for _Graph;
  cluster c-ecolorable for _Graph;
end;

theorem :: GLCOLO00:102
  for H being Subgraph of G holds G is c-ecolorable implies H is c-ecolorable;

registration
  let c; let G be c-ecolorable _Graph;
  cluster -> c-ecolorable for Subgraph of G;
end;

theorem :: GLCOLO00:103
  G1 == G2 & G1 is c-ecolorable implies G2 is c-ecolorable;

theorem :: GLCOLO00:104
  for G2 being reverseEdgeDirections of G1, E
  holds G1 is c-ecolorable iff G2 is c-ecolorable;

registration
  let c; let G1 be c-ecolorable _Graph; let E;
  cluster -> c-ecolorable for reverseEdgeDirections of G1, E;
end;

theorem :: GLCOLO00:105
  for G1 being addVertices of G2, V
  holds G1 is c-ecolorable iff G2 is c-ecolorable;

registration
  let c; let G2 be c-ecolorable _Graph; let V;
  cluster -> c-ecolorable for addVertices of G2, V;
end;

theorem :: GLCOLO00:106
  for G2 being c-ecolorable _Graph, v,e,w being object
  for G1 being addEdge of G2,v,e,w holds G1 is (c+`1)-ecolorable;

theorem :: GLCOLO00:107
  for G2 being c-ecolorable _Graph, v,e,w being object
  for G1 being addAdjVertex of G2,v,e,w holds G1 is (c+`1)-ecolorable;

theorem :: GLCOLO00:108
  for G2 being edgeless _Graph, v,e,w being object
  for G1 being addAdjVertex of G2,v,e,w holds G1 is 1-ecolorable;

registration
  let c; let G2 be c-ecolorable _Graph; let v,e,w be object;
  cluster -> (c+`1)-ecolorable for addEdge of G2,v,e,w;
  cluster -> (c+`1)-ecolorable for addAdjVertex of G2,v,e,w;
end;

theorem :: GLCOLO00:109
  for G2 being c-ecolorable _Graph, v being object
  for G1 being addAdjVertexAll of G2,v,V holds G1 is (c+`card V)-ecolorable;

registration
  let c; let G2 be c-ecolorable _Graph; let v be object; let V;
  cluster -> (c+`card V)-ecolorable for addAdjVertexAll of G2,v,V;
end;

theorem :: GLCOLO00:110
  for F being PGraphMapping of G1, G2
  st F is weak_SG-embedding & G2 is c-ecolorable holds G1 is c-ecolorable;

theorem :: GLCOLO00:111
  for F being PGraphMapping of G1, G2
  st F is isomorphism holds G1 is c-ecolorable iff G2 is c-ecolorable;

registration
  let c; let G be c-ecolorable _Graph;
  cluster G-isomorphic -> c-ecolorable for _Graph;
end;

definition
  let G;
  attr G is finite-ecolorable means
:: GLCOLO00:def 7 :: or finitely-ecolorable

  ex n st G is n-ecolorable;
end;

registration
  cluster edge-finite -> finite-ecolorable for _Graph;
  cluster edgeless -> finite-ecolorable for _Graph;
  cluster finite-ecolorable -> locally-finite for _Graph;
  let n;
  cluster n-ecolorable -> finite-ecolorable for _Graph;
end;

registration
  cluster finite-ecolorable for _Graph;
  cluster non finite-ecolorable for _Graph;
end;

registration
  let G be finite-ecolorable _Graph;
  cluster -> finite-ecolorable for Subgraph of G;
end;

theorem :: GLCOLO00:112
  G1 == G2 & G1 is finite-ecolorable implies G2 is finite-ecolorable;

theorem :: GLCOLO00:113
  for G2 being reverseEdgeDirections of G1, E
  holds G1 is finite-ecolorable iff G2 is finite-ecolorable;

registration
  let G1 be finite-ecolorable _Graph; let E;
  cluster -> finite-ecolorable for reverseEdgeDirections of G1, E;
end;

registration
  let G1 be non finite-ecolorable _Graph; let E;
  cluster -> non finite-ecolorable for reverseEdgeDirections of G1, E;
end;

theorem :: GLCOLO00:114
  for G1 being addVertices of G2, V
  holds G1 is finite-ecolorable iff G2 is finite-ecolorable;

registration
  let G2 be finite-ecolorable _Graph; let V;
  cluster -> finite-ecolorable for addVertices of G2, V;
end;

registration
  let G2 be non finite-ecolorable _Graph; let V;
  cluster -> non finite-ecolorable for addVertices of G2, V;
end;

theorem :: GLCOLO00:115
  for v,e,w being object, G1 being addEdge of G2,v,e,w
  holds G1 is finite-ecolorable iff G2 is finite-ecolorable;

registration
  let G2 be finite-ecolorable _Graph, v,e,w be object;
  cluster -> finite-ecolorable for addEdge of G2,v,e,w;
end;

registration
  let G2 be non finite-ecolorable _Graph, v,e,w be object;
  cluster -> non finite-ecolorable for addEdge of G2,v,e,w;
end;

theorem :: GLCOLO00:116
  for v,e,w being object, G1 being addAdjVertex of G2,v,e,w
  holds G1 is finite-ecolorable iff G2 is finite-ecolorable;

registration
  let G2 be finite-ecolorable _Graph, v,e,w be object;
  cluster -> finite-ecolorable for addAdjVertex of G2,v,e,w;
end;

registration
  let G2 be non finite-ecolorable _Graph, v,e,w be object;
  cluster -> non finite-ecolorable for addAdjVertex of G2,v,e,w;
end;

theorem :: GLCOLO00:117
  for v being object, V being finite set, G1 being addAdjVertexAll of G2,v,V
  holds G1 is finite-ecolorable iff G2 is finite-ecolorable;

registration
  let G2 be finite-ecolorable _Graph, v be object; let V be finite set;
  cluster -> finite-ecolorable for addAdjVertexAll of G2,v,V;
end;

theorem :: GLCOLO00:118
  for F being PGraphMapping of G1,G2
  st F is weak_SG-embedding & G2 is finite-ecolorable
  holds G1 is finite-ecolorable;

theorem :: GLCOLO00:119
  for F being PGraphMapping of G1, G2
  st F is isomorphism holds G1 is finite-ecolorable iff G2 is finite-ecolorable
;

registration
  let G be finite-ecolorable _Graph;
  cluster G-isomorphic -> finite-ecolorable for _Graph;
end;

definition
  let G;
  func G.eChromaticNum() -> Cardinal equals
:: GLCOLO00:def 8 :: chi prime
  meet { c where c is cardinal Subset of G.size() : G is c-ecolorable };
end;

theorem :: GLCOLO00:120
  G.eChromaticNum() c= G.size();

theorem :: GLCOLO00:121
  G is edgeless iff G.eChromaticNum() = 0;

registration
  let G be edgeless _Graph;
  cluster G.eChromaticNum() -> zero;
end;

registration
  let G be non edgeless _Graph;
  cluster G.eChromaticNum() -> non zero;
end;

theorem :: GLCOLO00:122
  (G is c-ecolorable & for d being Cardinal st G is d-ecolorable holds c c= d)
  iff G.eChromaticNum() = c;

registration
  let G be finite-ecolorable _Graph;
  cluster G.eChromaticNum() -> natural;
end;

definition
  let G be finite-ecolorable _Graph;
  redefine func G.eChromaticNum() -> Nat;
end;

theorem :: GLCOLO00:123
  for G being loopless _Graph holds G.supDegree() c= G.eChromaticNum();

theorem :: GLCOLO00:124
  G1 == G2 implies G1.eChromaticNum() = G2.eChromaticNum();

theorem :: GLCOLO00:125
  for G2 being reverseEdgeDirections of G1, E
  holds G1.eChromaticNum() = G2.eChromaticNum();

theorem :: GLCOLO00:126
  for H being Subgraph of G holds H.eChromaticNum() c= G.eChromaticNum();

theorem :: GLCOLO00:127
  for G1 being addVertices of G2, V
  holds G1.eChromaticNum() = G2.eChromaticNum();

theorem :: GLCOLO00:128
  for v,e,w being object, G1 being addEdge of G2,v,e,w
  holds G1.eChromaticNum() c= G2.eChromaticNum() +` 1;

theorem :: GLCOLO00:129
  for v,e,w being object, G1 being addAdjVertex of G2,v,e,w
  holds G1.eChromaticNum() c= G2.eChromaticNum() +` 1;

theorem :: GLCOLO00:130
  for G2 being edgeless _Graph, v being Vertex of G2, e,w being object
  for G1 being addAdjVertex of G2,v,e,w
  st not w in the_Vertices_of G2 holds G1.eChromaticNum() = 1;

theorem :: GLCOLO00:131
  for G2 being edgeless _Graph, v,e being object, w being Vertex of G2
  for G1 being addAdjVertex of G2,v,e,w
  st not v in the_Vertices_of G2 holds G1.eChromaticNum() = 1;

theorem :: GLCOLO00:132
  for v being object, G1 being addAdjVertexAll of G2,v,V
  holds G1.eChromaticNum() c= G2.eChromaticNum() +` card V;

theorem :: GLCOLO00:133
  for F being PGraphMapping of G1, G2 st F is weak_SG-embedding
  holds G1.eChromaticNum() c= G2.eChromaticNum();

theorem :: GLCOLO00:134
  for F being PGraphMapping of G1, G2 st F is isomorphism
  holds G1.eChromaticNum() = G2.eChromaticNum();

theorem :: GLCOLO00:135
  for G2 being G1-isomorphic _Graph
  holds G1.eChromaticNum() = G2.eChromaticNum();

theorem :: GLCOLO00:136
  G is _trivial implies G.eChromaticNum() = G.size();

begin :: Total Colorings

definition
  let G;
  mode TColoring of G means
:: GLCOLO00:def 9

  ex f being VColoring of G, g being EColoring of G st it = [f,g];
end;

registration
  let G;
  cluster -> pair for TColoring of G;
end;

reserve t for TColoring of G;

notation
  let G, t;
  synonym t_V for t`1;
  synonym t_E for t`2;
end;

registration
  let G, t;
  reduce [ t_V , t_E ] to t;
end;

definition
  let G, t;
  redefine func t_V -> VColoring of G;
  redefine func t_E -> EColoring of G;
end;

definition
  let G, f, g;
  redefine func [f, g] -> TColoring of G;
end;

theorem :: GLCOLO00:137
  G is edgeless implies [f, {}] is TColoring of G;

theorem :: GLCOLO00:138
  for H being Subgraph of G holds
    [ t_V | the_Vertices_of H , t_E | the_Edges_of H ] is TColoring of H;

theorem :: GLCOLO00:139
  for G1 being addVertices of G2, V, t being TColoring of G2
  for h being Function st dom h = V \ the_Vertices_of G2
  holds [t_V +* h, t_E] is TColoring of G1;

theorem :: GLCOLO00:140
  for v,x being object, G1 being addVertex of G2,v, t being TColoring of G2
  holds [t_V +* (v .--> x), t_E] is TColoring of G1;

theorem :: GLCOLO00:141
  for e being object, v,w being Vertex of G2, G1 being addEdge of G2,v,e,w
  for t being TColoring of G2, y being object st not e in the_Edges_of G2
  holds [t_V, t_E +* (e .--> y)] is TColoring of G1;

theorem :: GLCOLO00:142
  for e being object, v,w,u being Vertex of G2, G1 being addEdge of G2,v,e,w
  for t being TColoring of G2, x,y being object st not e in the_Edges_of G2
  holds [t_V +* (u .--> x), t_E +* (e .--> y)] is TColoring of G1;

theorem :: GLCOLO00:143
  for v,e being object, w being Vertex of G2, G1 being addAdjVertex of G2,v,e,w
  for t being TColoring of G2, x,y being object
  st not e in the_Edges_of G2 & not v in the_Vertices_of G2
  holds [t_V +* (v .--> x), t_E +* (e .--> y)] is TColoring of G1;

theorem :: GLCOLO00:144
  for v being Vertex of G2, e,w being object, G1 being addAdjVertex of G2,v,e,w
  for t being TColoring of G2, x,y being object
  st not e in the_Edges_of G2 & not w in the_Vertices_of G2
  holds [t_V +* (w .--> x), t_E +* (e .--> y)] is TColoring of G1;

theorem :: GLCOLO00:145
  for F being PGraphMapping of G1,G st F is total
  holds [ t_V*(F_V) , t_E*(F_E) ] is TColoring of G1;

definition
  let G, t;
  attr t is proper means
:: GLCOLO00:def 10

  t_V is proper & t_E is proper &
    for v being Vertex of G holds not t_V.v in t_E.:v.edgesInOut();
end;

theorem :: GLCOLO00:146
  t is proper iff t_V is proper & t_E is proper &
    for e,v,w being object st e Joins v,w,G holds t_V.v <> t_E.e;

theorem :: GLCOLO00:147
  t_V is proper & t_E is proper & rng(t_V) misses rng(t_E) implies t is proper;

theorem :: GLCOLO00:148
  t is proper iff for e1,e2,v,w1,w2 being object
    st e1 Joins v,w1,G & e2 Joins v,w2,G
    holds t_V.v <> t_V.w1 & t_V.v <> t_E.e1 &
      (e1 <> e2 implies t_E.e1 <> t_E.e2);

theorem :: GLCOLO00:149
  g is proper implies ex g9 being proper EColoring of G
    st rng f misses rng g9 & card rng g = card rng g9;

theorem :: GLCOLO00:150
  f is proper implies ex f9 being VColoring of G
    st f9 is proper & rng f9 misses rng g & card rng f = card rng f9;

registration
  let G be loopless _Graph;
  cluster proper for TColoring of G;
end;

registration
  let G be loopless _Graph;
  let t be proper TColoring of G;
  cluster t_V -> proper for VColoring of G;
  cluster t_E -> proper for EColoring of G;
end;

theorem :: GLCOLO00:151
  for H being Subgraph of G, t9 being TColoring of H
  st t9 = [ t_V | the_Vertices_of H , t_E | the_Edges_of H ] & t is proper
  holds t9 is proper;

theorem :: GLCOLO00:152
  for t1 being TColoring of G1, t2 being TColoring of G2
  st G1 == G2 & t1 = t2 & t1 is proper holds t2 is proper;

theorem :: GLCOLO00:153
  for G2 being reverseEdgeDirections of G1, E
  for t1 being TColoring of G1, t2 being TColoring of G2
  st t1 = t2 holds t1 is proper iff t2 is proper;

theorem :: GLCOLO00:154
  for G1 being addVertices of G2, V
  for t1 being TColoring of G1, t2 being TColoring of G2, h being Function
  st dom h = V\the_Vertices_of G2 & t1_V = t2_V+*h & t1_E = t2_E & t2 is proper
  holds t1 is proper;

theorem :: GLCOLO00:155
  for y,e being object, v,w being Vertex of G2, G1 being addEdge of G2,v,e,w
  for t1 being TColoring of G1, t2 being TColoring of G2
  st not e in the_Edges_of G2 & v,w are_adjacent &
    t1_V = t2_V & t1_E = t2_E +* (e .--> y) &
    not y in (rng t2_V)\/rng t2_E & t2 is proper
  holds t1 is proper;

theorem :: GLCOLO00:156
  for v,e being object, w being Vertex of G2, G1 being addEdge of G2,v,e,w
  for t1 being TColoring of G1, t2 being TColoring of G2, x,y being object
  st not e in the_Edges_of G2 & v <> w &
    t1_V = t2_V +* (v .--> x) & t1_E = t2_E +* (e .--> y) &
    {x,y} misses (rng t2_V)\/rng t2_E & x <> y & t2 is proper
  holds t1 is proper;

theorem :: GLCOLO00:157
  for v being Vertex of G2, e,w being object, G1 being addEdge of G2,v,e,w
  for t1 being TColoring of G1, t2 being TColoring of G2, x,y being object
  st not e in the_Edges_of G2 & v <> w &
    t1_V = t2_V +* (w .--> x) & t1_E = t2_E +* (e .--> y) &
    {x,y} misses (rng t2_V)\/rng t2_E & x <> y & t2 is proper
  holds t1 is proper;

theorem :: GLCOLO00:158
  for v,e being object, w being Vertex of G2, G1 being addAdjVertex of G2,v,e,w
  for t1 being TColoring of G1, t2 being TColoring of G2, x,y being object
  st not e in the_Edges_of G2 & not v in the_Vertices_of G2 &
    t1_V = t2_V +* (v .--> x) & t1_E = t2_E +* (e .--> y) &
    not y in (rng t2_V)\/rng t2_E & x <> y & x <> t2_V.w & t2 is proper
  holds t1 is proper;

theorem :: GLCOLO00:159
  for v being Vertex of G2, e,w being object, G1 being addAdjVertex of G2,v,e,w
  for t1 being TColoring of G1, t2 being TColoring of G2, x,y being object
  st not e in the_Edges_of G2 & not w in the_Vertices_of G2 &
    t1_V = t2_V +* (w .--> x) & t1_E = t2_E +* (e .--> y) &
    not y in (rng t2_V)\/rng t2_E & x <> y & x <> t2_V.v & t2 is proper
  holds t1 is proper;

theorem :: GLCOLO00:160
  for F being PGraphMapping of G1,G, t9 being TColoring of G1
  st F is weak_SG-embedding & t9 = [ t_V*(F_V) , t_E*(F_E) ] & t is proper
  holds t9 is proper;

definition
  let c, G;
  attr G is c-tcolorable means
:: GLCOLO00:def 11
  ex t being TColoring of G st t is proper & card((rng t_V)\/rng t_E) c= c;
end;

theorem :: GLCOLO00:161
  c1 c= c2 & G is c1-tcolorable implies G is c2-tcolorable;

theorem :: GLCOLO00:162
  G is c-tcolorable implies G is c-vcolorable & G is c-ecolorable;

theorem :: GLCOLO00:163
  G is c1-vcolorable c2-ecolorable implies G is (c1+`c2)-tcolorable;

:: might need Proof outside this article
theorem :: GLCOLO00:164
  G is edgeless & f is proper & t = [ f , {} ] implies t is proper;

theorem :: GLCOLO00:165
  G is edgeless iff G is 1-tcolorable;

registration
  let c be non zero Cardinal;
  cluster c-tcolorable for _Graph;
end;

theorem :: GLCOLO00:166
  for H being Subgraph of G holds G is c-tcolorable implies H is c-tcolorable;

registration
  cluster -> non 0-tcolorable for _Graph;
  cluster edgeless -> 1-tcolorable for _Graph;
  cluster 1-tcolorable -> edgeless for _Graph;
  let c be non zero Cardinal;
  let G be c-tcolorable _Graph;
  cluster -> c-tcolorable for Subgraph of G;
end;

registration
  let c;
  cluster c-tcolorable -> loopless for _Graph;
end;

theorem :: GLCOLO00:167
  G1 == G2 & G1 is c-tcolorable implies G2 is c-tcolorable;

theorem :: GLCOLO00:168
  for G2 being reverseEdgeDirections of G1, E
  holds G1 is c-tcolorable iff G2 is c-tcolorable;

registration
  let c be non zero Cardinal;
  let G1 be c-tcolorable _Graph;
  let E;
  cluster -> c-tcolorable for reverseEdgeDirections of G1, E;
end;

theorem :: GLCOLO00:169
  for G1 being addVertices of G2, V
  holds G1 is c-tcolorable iff G2 is c-tcolorable;

registration
  let c be non zero Cardinal;
  let G2 be c-tcolorable _Graph;
  let V;
  cluster -> c-tcolorable for addVertices of G2, V;
end;

theorem :: GLCOLO00:170
  for e being object, v,w being Vertex of G2, G1 being addEdge of G2,v,e,w
  st v,w are_adjacent & G2 is c-tcolorable holds G1 is (c+`1)-tcolorable;

theorem :: GLCOLO00:171
  for v,e,w being object, G1 being addEdge of G2,v,e,w
  st v <> w & G2 is c-tcolorable holds G1 is (c+`2)-tcolorable;

theorem :: GLCOLO00:172
  for G2 being non edgeless _Graph, v,e,w being object
  for G1 being addAdjVertex of G2,v,e,w
  st G2 is c-tcolorable holds G1 is (c+`1)-tcolorable;

theorem :: GLCOLO00:173
  for v being Vertex of G2, e,w being object, G1 being addAdjVertex of G2,v,e,w
  st not e in the_Edges_of G2 & not w in the_Vertices_of G2 & v is endvertex
  holds G2 is c-tcolorable implies G1 is c-tcolorable;

theorem :: GLCOLO00:174
  for G2 being edgeless _Graph, v,e,w being object
  for G1 being addAdjVertex of G2,v,e,w holds G1 is 3-tcolorable;

theorem :: GLCOLO00:175
  for v being object, G1 being addAdjVertexAll of G2,v,V
  st G2 is c-tcolorable holds G1 is (c+`1+`card V)-tcolorable;

theorem :: GLCOLO00:176
  for F being PGraphMapping of G1, G2
  st F is weak_SG-embedding & G2 is c-tcolorable holds G1 is c-tcolorable;

theorem :: GLCOLO00:177
  for F being PGraphMapping of G1, G2
  st F is isomorphism holds G1 is c-tcolorable iff G2 is c-tcolorable;

registration
  let c be non zero Cardinal;
  let G be c-tcolorable _Graph;
  cluster G-isomorphic -> c-tcolorable for _Graph;
end;

definition
  let G;
  attr G is finite-tcolorable means
:: GLCOLO00:def 12 :: or finitely-tcolorable

  ex n st G is n-tcolorable;
end;

registration
  cluster finite-tcolorable -> loopless for _Graph;
  cluster edgeless -> finite-tcolorable for _Graph;
  let n;
  cluster n-tcolorable -> finite-tcolorable for _Graph;
end;

registration
  cluster finite-tcolorable for _Graph;
  cluster non finite-tcolorable for _Graph;
end;

registration
  let G be finite-tcolorable _Graph;
  cluster -> finite-tcolorable for Subgraph of G;
end;

theorem :: GLCOLO00:178
  G1 == G2 & G1 is finite-tcolorable implies G2 is finite-tcolorable;

theorem :: GLCOLO00:179
  for G2 being reverseEdgeDirections of G1, E
  holds G1 is finite-tcolorable iff G2 is finite-tcolorable;

registration
  let G1 be finite-tcolorable _Graph; let E;
  cluster -> finite-tcolorable for reverseEdgeDirections of G1, E;
end;

registration
  let G1 be non finite-tcolorable _Graph; let E;
  cluster -> non finite-tcolorable for reverseEdgeDirections of G1, E;
end;

theorem :: GLCOLO00:180
  for G1 being addVertices of G2, V
  holds G1 is finite-tcolorable iff G2 is finite-tcolorable;

registration
  let G2 be finite-tcolorable _Graph; let V;
  cluster -> finite-tcolorable for addVertices of G2, V;
end;

registration
  let G2 be non finite-tcolorable _Graph; let V;
  cluster -> non finite-tcolorable for addVertices of G2, V;
end;

theorem :: GLCOLO00:181
  for v,e,w being object, G1 being addEdge of G2,v,e,w
  st v <> w holds G1 is finite-tcolorable iff G2 is finite-tcolorable;

theorem :: GLCOLO00:182
  for v,e,w being object, G1 being addAdjVertex of G2,v,e,w
  holds G1 is finite-tcolorable iff G2 is finite-tcolorable;

registration
  let G2 be finite-tcolorable _Graph, v,e,w be object;
  cluster -> finite-tcolorable for addAdjVertex of G2,v,e,w;
end;

registration
  let G2 be non finite-tcolorable _Graph, v,e,w be object;
  cluster -> non finite-tcolorable for addAdjVertex of G2,v,e,w;
end;

theorem :: GLCOLO00:183
  for v being object, V being finite set, G1 being addAdjVertexAll of G2,v,V
  holds G1 is finite-tcolorable iff G2 is finite-tcolorable;

registration
  let G2 be finite-tcolorable _Graph, v be object; let V be finite set;
  cluster -> finite-tcolorable for addAdjVertexAll of G2,v,V;
end;

theorem :: GLCOLO00:184
  for F being PGraphMapping of G1,G2
  st F is weak_SG-embedding & G2 is finite-tcolorable
  holds G1 is finite-tcolorable;

theorem :: GLCOLO00:185
  for F being PGraphMapping of G1, G2
  st F is isomorphism holds G1 is finite-tcolorable iff G2 is finite-tcolorable
;

registration
  let G be finite-tcolorable _Graph;
  cluster G-isomorphic -> finite-tcolorable for _Graph;
end;

definition
  let G be _Graph;
  func G.tChromaticNum() -> Cardinal equals
:: GLCOLO00:def 13 :: chi double prime
  meet { c where c is cardinal Subset of G.order()+`G.size()
        : G is c-tcolorable };
end;

theorem :: GLCOLO00:186
  G is loopless implies G is G.tChromaticNum()-tcolorable;

theorem :: GLCOLO00:187
  G is non loopless iff G.tChromaticNum() = 0;

registration
  let G be loopless _Graph;
  cluster G.tChromaticNum() -> non zero;
end;

registration
  let G be non loopless _Graph;
  cluster G.tChromaticNum() -> zero;
end;

theorem :: GLCOLO00:188
  G.tChromaticNum() c= G.order()+`G.size();

theorem :: GLCOLO00:189
  G is c-tcolorable implies G.tChromaticNum() c= c;

theorem :: GLCOLO00:190
  (G is c-tcolorable & for d being Cardinal st G is d-tcolorable holds c c= d)
  implies G.tChromaticNum() = c;

registration
  let G be finite-tcolorable _Graph;
  cluster G.tChromaticNum() -> natural;
end;

definition
  let G be finite-tcolorable _Graph;
  redefine func G.tChromaticNum() -> Nat;
end;

theorem :: GLCOLO00:191
  G.vChromaticNum() c= G.tChromaticNum();

theorem :: GLCOLO00:192
  for G being loopless _Graph holds G.eChromaticNum() c= G.tChromaticNum();

theorem :: GLCOLO00:193
  G.tChromaticNum() c= G.vChromaticNum() +` G.eChromaticNum();

theorem :: GLCOLO00:194
  for G being loopless _Graph holds G.supDegree()+`1 c= G.tChromaticNum();

theorem :: GLCOLO00:195
  G is edgeless iff G.tChromaticNum() = 1;

theorem :: GLCOLO00:196
  for G being loopless non edgeless _Graph holds 3 c= G.tChromaticNum();

theorem :: GLCOLO00:197
  for G being loopless _Graph, H being Subgraph of G
  holds H.tChromaticNum() c= G.tChromaticNum();

theorem :: GLCOLO00:198
  G1 == G2 implies G1.tChromaticNum() = G2.tChromaticNum();

theorem :: GLCOLO00:199
  for G2 being reverseEdgeDirections of G1, E
  holds G1.tChromaticNum() = G2.tChromaticNum();

theorem :: GLCOLO00:200
  for G1 being addVertices of G2, V
  holds G1.tChromaticNum() = G2.tChromaticNum();

theorem :: GLCOLO00:201
  for G2 being non edgeless _Graph, v,e,w being object
  for G1 being addAdjVertex of G2,v,e,w
  holds G1.tChromaticNum() c= G2.tChromaticNum() +` 1;

theorem :: GLCOLO00:202
  for G2 being edgeless _Graph, v being Vertex of G2, e,w being object
  for G1 being addAdjVertex of G2,v,e,w
  st not w in the_Vertices_of G2 holds G1.tChromaticNum() = 3;

theorem :: GLCOLO00:203
  for G2 being edgeless _Graph, v,e being object, w being Vertex of G2
  for G1 being addAdjVertex of G2,v,e,w
  st not v in the_Vertices_of G2 holds G1.tChromaticNum() = 3;

theorem :: GLCOLO00:204
  for v being object, G1 being addAdjVertexAll of G2,v,V
  holds G1.tChromaticNum() c= G2.tChromaticNum() +` 1 +` card V;

theorem :: GLCOLO00:205
  for G1 being _Graph, G2 being loopless _Graph
  for F being PGraphMapping of G1, G2 st F is weak_SG-embedding
  holds G1.tChromaticNum() c= G2.tChromaticNum();

theorem :: GLCOLO00:206
  for F being PGraphMapping of G1, G2
  st F is isomorphism holds G1.tChromaticNum() = G2.tChromaticNum();

theorem :: GLCOLO00:207
  for G2 being G1-isomorphic _Graph
  holds G1.tChromaticNum() = G2.tChromaticNum();
